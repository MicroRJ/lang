// STATUS [FIXED]:
// GC would trigger when a new object
// was created, however, I was careless
// and I was modifying the value of
// where the object resided before the
// object was created, making the gc
// think that the object was a different
// type.
// ; locals[b.x].tag = TAG_TAB;
// ; locals[b.x].t   = elf_newtab(R);
// So when the gc would check local at b.x
// it would think that it was a table, when
// it wasn't.
// The fix is just to create the object,
// then modify the value.
__gc()
for i in 0..422 ? {let thing={}}
__logging(true)
for i in 0..1024 ? {
	let thing = {}
	pf("i: ", i, " = ", thing)
}
pf("here")
leave (false)
// STATUS: [FIXED]
// Solution:
// It was a simple facepalm moment bug, I was
// iterating over the GC array whilst removing
// items from it by swapping the current item
// with the last one but I forgot to decrement
// the index so that it wouldn't skip item that
// I swapped with.
// Bug:
// The GC fails to actually collect anything,
// it marks everything properly and it tells
// you so, but it doesn't actually collect
// the unmarked objects.
// here are some logs:
// here marked means the number of objects that went
// from specifically from white to black.
// (tbf) = to be freed
// / = the total number of objects
// (->) what it should go down to
// DEBUG lgc.c[142] elf_collect(): tbf: 426/512 -> 86
// DEBUG lgc.c[168] elf_collect():         => leaked: 213, 1, 0
// DEBUG lgc.c[142] elf_collect(): tbf: 938/1024 -> 86
// DEBUG lgc.c[168] elf_collect():         => leaked: 469, 1, 0
// DEBUG lgc.c[142] elf_collect(): tbf: 1962/2048 -> 86
// DEBUG lgc.c[168] elf_collect():         => leaked: 981, 1, 0
//
for i in 0..100000 ? {
	let thing = {}
}
pf("here")
leave (false)
// [STATUS:FIXED]
// Bug: given the language specs,
// a() should evaluate each time
// the check is made, however it
// doesn't.
// Solution:
// Simply fix the jump so that it
// returns to where the condition
// is reevaluated completely.
a = fun() ? { pf("a") leave 24 }
for i in 0..a() ? {
	pf(i)
}
leave (false)
__logging(false)

fibtab = {}
fibmem = fun (n) ? {
	if n < 2 ? leave n
	fibtab[n] ?= fibmem(n - 1) + fibmem(n - 2)
	leave fibtab[n]
}

fibraw = fun (n) ? {
	if n < 2 ? leave n
	leave fibraw(n - 1) + fibraw(n - 2)
}

let fib = fibmem

failed = false

let test = fun (x,y) ? {
	let k = fib(x)
	failed ?= k != y
	pf("fib(", x , ") => ", k)
	if k != y ? pf("	expected: ", y)
}

test(0,0)
test(1,1)
test(2,1)
test(3,2)
test(4,3)
test(10,55)
test(25,75025)
if fib == fibmem ? {
	test(30,832040)
	test(35,9227465)
	test(40,102334155)
	/* todo: when come back, this number is too large
	to be represented literally, fix this, add to
	constant pool */
	test(65,17167680177565)
}

if failed ? {
	fibtab:iter(fun(x,y) ? {
		pf(x, " = ", y)
	})
}
// __logging(true)
// finally __logging(false)

testfn = fun() ? {
	// finally pf(".7")
	// pf(".0")
	// finally pf(".6")
	// pf(".1")
	// finally pf(".5")
	// pf(".2")
	// finally pf(".4")
	// pf(".3")

	finally leave "leave 4"
	finally leave "leave 3"
	finally leave "leave 2"
	finally leave "leave 1"
	leave "leave 0"
}

failed = testfn() != "leave 4"
if (failed) ? pf("failed")
leave failed
_chdir("code/tests")


let sysfile = fopen("filefind.web2.ignore","wb")
finally fclose(sysfile)

let _time = clocktime()
finally pf(" => took: ", timediffs(_time))
finally fpf(sysfile,"\n\n\n\n => took: ", timediffs(_time), "\n")

fpf(sysfile,"found files:\n")
let dir = "C:"
pf("filtering files in: ",dir)

let list = listdir(dir,fun(file,flags) ? {
	if 0 ?
	elif file.name:match("*.js|*.html|*.css|*.xml|*.php|*.ts") ?
	// elif file.name:match("*.cpp")  ?
	// elif file.name:match("*.hpp")  ?
	// elif file.name:match("*.c")    ?
	// elif file.name:match("*.h")    ?
	// elif file.name:match("*.swift") ?
	// elif file.name:match("*.obj|*.dll|*.lib|*.exp|*.pdb|*.exe|*.so") ?
	then {
		fpf(sysfile,file.name,", ",file.path, "\n")
	}
	leave true
})
__logging(false)
let j
for i in (((0)))..(((10))) ? j = i
failed = j != 9
/* global */

failed = false

test = fun(x) ? {
	iff x ? failed = true
}

if __a ? pf("cannot conduct test")
if __b ? pf("cannot conduct test")
if __c ? pf("cannot conduct test")

fun () ? {
	__a = true
	fun () ? { __b = true
		fun () ? { __c = true
			test(__a == true)
			test(__b == true)
			test(__c == true)
		}()
	}()
}()


call = fun (x) ? {
	x()
}


fun(x,y,z) ? {
	test(x == 1)
	test(y == 2)
	test(z == 3)
	call(fun () ? {
		test(x == 1)
		test(y == 2)
		test(z == 3)
	})
} (1,2,3)


leave failedfailed = true
(fun()?(fun()?(fun()?(fun()?{failed=false})))) ()()()()

if failed ? pf("failed") else pf("success")
mytable = {}
mytable = {}
mytable = {}
mytable = {}
mytable = {}

gc()


//
//    [1,2,3,4]
//  [1,2]    [3,4]
// [1] [2]  [3] [4]
// ----------------
// [2] [1]  [4] [3]
//  [4,3]    [2,1]
//    [4,3,2,1]
//

//
//    [1,8,7,9]
//  [1,8]    [7,9]
// [1] [8]  [7] [9]
// ----------------
// [8] [1]  [9] [7]
//  [9,7]    [8,1]
//    [9,8,7,1]
//

// C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build

local sysfile = fopen("hashbench.ignore","ab")
fpf(sysfile,"Hash table benchmarks:\n")

local run = fun(x) ? {
	gcpause()
	pf("filtering files in: ", x)
	_time = clocktime()
	// listdir takes a function used for filtering!
	local list = listdir(x,fun(file,flags) ? {
		if 512 < flags.n ? {
			leave false
		}
		flags.n = flags.n + 1;
		// fpf(sysfile,"file: ",file.name,"\n")
		if file.name:match("*.h") || file.name:match("*.c") ? {
			// if file.name:match("vcvars*.bat") ? {
			pf("found: ", file.name)
		}
		leave true
	})
	fpf(sysfile,"elapsed: ", timediffs(_time), "\n")
	fpf(sysfile,"items: ", list:length, ", hits: ", list:collisions, "\n")
	fpf(sysfile,"====================================\n")
}
// run("C:/Program Files/Microsoft Visual Studio")
// run("C:/Program Files")
run("W:")
__logging(false)
if false ? failed = true
iff true ? failed = true
let test = fun(x,y) ? {
	failed ?= x != y
	if x != y ? pf("failed")
}
test(0 <= 1, true)
test(0 <= 1, true)
test(1 <= 1, true)
test(0 >= 0, true)
test(1 >= 1, true)
test(1 >= 0, true)
test(0 && 0 && 0 && 0, 0)
test(0 || 0 || 0 || 0, 0)
test(0 && 0 || 0, 0)
test(0 && 0 || 1, 1)
test(0 && 1 || 2, 1)
test(0 && 0, 0)
test(0 && 1, 0)
test(1 && 1, 1)
test(0 || 0, 0)
test(0 || 1, 1)
test(1 || 1, 1)
test(0 && 0 || 0, 0)


for x in 0..4 ? {
	if   x == 0 ? test(x == 0, true)
	elif x == 1 ? test(x == 1, true)
elif x == 2 ? test(x == 2, true)
else test(x >= 3, true)
}

if failed ? {
	pf("failed")
}

leave failedcore.xxx = fun(x) ? {	leave 1	}
core.yyy = fun(x) ? {	leave 2	}
core.zzz = fun(x) ? {	leave 3	}
leave core// x -> y ~= y -> x
ordinal = fun(x,y,z) -> {
	0,0,0  -> "zero"
	0,0,1  -> "one"
	0,1,0  -> "two"
	0,1,1  -> "three"
	1,0,0  -> "four"
	1,0,1  -> "five"
	1,1,0  -> "six"
	1,1,1  -> "seven"
	else -> "invalid"
}
add = fun(x,y) ? (x + y)
sub = ~add
mul = fun(x,y) ? (x * y)
div = ~mul
init = {1,2,3,4,5,6,7,8,9}
pf(init)

simp = fun() ? {
	local list = {}
	for i in 0..4 ? {
		local x = i
		local y = i*2
		local z = i*4

		list[i] = fun() ? {
			v = {}
			v.x = x
			v.y = y
			v.z = z
			leave v
		}
	}
	for i in 0..4 ? {
		pf(list[i]())
	}
}

simp()

for x in 0..4 ? {
	if x == 0 ? {
		pf(x, " if 0")
	} elif x == 1 ? {
		pf(x, " elif 1")
	} elif x == 2 ? {
		pf(x, " elif 2")
	} else {
		pf(x, " else")
	}
}

if 1 && 2 || 0 ? {
	pf("welcome")
} else {
	pf("not welcome");
}
test = fun(x,y) ? {
	if x != y ? {
		pf("FAIL: expected ", y, " instead got ", x)
	}
}
pf("begin")

_0 = fun() ? { pf("0") leave 0 }
_1 = fun() ? { pf("1") leave 1 }
_2 = fun() ? { pf("2") leave 2 }
_3 = fun() ? { pf("3") leave 3 }
{
	__logging(true)
	let istrue = 1 && 1
	__logging(false)
}

// let table = {}
// table.a = "a"
// table.b = "b"
// table.c = "c"
// table.d = "d"
// pf(table)

let test = fun(x,y) ? {
	iff x == y ? pf("failed")
}

while 0 ? pf("failed")
do pf("success") while 0

test(1 == 1 && 1 == 1, true)
test(1 == 1 && 1 == 0, false)
test(1,1)
test(0,0)
test(0 <= 1, true)
test(0 <= 1, true)
test(1 <= 1, true)
test(0 >= 0, true)
test(1 >= 1, true)
test(1 >= 0, true)
test(0 && 0 && 0 && 0, 0)
test(0 || 0 || 0 || 0, 0)
test(0 && 0 || 0, 0)
test(0 && 0 || 1, 1)
test(0 && 1 || 2, 1)
test(0 && 0, 0)
test(0 && 1, 0)
test(1 && 1, 1)
test(0 || 0, 0)
test(0 || 1, 1)
test(1 || 1, 1)
test(0 && 0 || 0, 0)

// if 1 && 1 ? pf("welcome")

// let xorshift = fun(x) ? {
// 	x = x ^ x << 13
// 	x = x ^ x >> 7
// 	x = x ^ x << 17
// 	leave x
// }
// let inn = xorshift(5280)
// pf("xor: ", inn)
// // // pf(1,2,3,4,5,6,7,8,9)
// // // let foo = fun() ? (2)
// // // let x = foo()
// // // pf(x)

// // /* clearly this is not how you do jitting,
// // we don't even know the types of anything */
// // let enum xorshiftjit = jit(xorshift)


/* todo: experiment with name spaces */

/* check include guard */
core2 = load "code/tests/core.lang"
core2 = load "code/tests/core.lang"
core2 = load "code/tests/core.lang"
core2 = load "code/tests/core.lang"
core2 = load "code/tests/core.lang"


load "code/tests/match.lang"

pf(pc(), ": calling core functions")

core2.xxx()
core2.yyy()
core2.zzz()

pf(pc(), ": done...")


failed = false
let test = fun(x,y) ? {
	if x != y ? pf("failed")
	if x != y ? failed = true
}
test("":match("*"),true)
test("":match("?"),false)
test("file.obj":match("*.obj|*.dll"),true)
test("file.dll":match("*.obj|*.dll"),true)
test("xxxyyyzzz":match("xxx*www"),false)
test("x.x":match("x?x"),true)
test(".x.":match("?x?"),true)
test(".x.":match("?y?"),false)
test("x.x":match("*x"),true)
test("x.x":match("x*"),true)
test("x.x":match("x*x"),true)
leave failedlet length = ({1,2,3}):length()
failed = length != 3
local x,y
x,y = 1,1
if unknown ? {
	x + y
} else {
	x,y = {"welcome"},{"welcome"}
}
x + y


let sampletable = {}
sampletable.j ?= 1
sampletable.j ?= 77
sampletable.j ?= 777
sampletable.j ?= 777
sampletable.j ?= 777
leave sampletable == 1if 0 ? {
	/* -- 4.10.24 [FIXED]
	| the loop does not execute, remove "__logging(true)" and
	| it works again  */
	let x = 0
	let y = 12
	__logging(true)
	for i in x..y ? pf("bug")
	/*
	---- BYTECODE ---- [WORKING]
	0000    loadint(x=0,y=0)
	0001    loadint(x=1,y=12)
	0002    lt(x=3,y=2,z=1)
	0003    jz(x=7,y=3)
	0004    loadglobal(x=3,y=9)  // C()
	0005    loadglobal(x=4,y=44)  // "bug"
	0006    call(x=3,y=1,z=0)
	....
	---- BYTECODE ---- [FAILING]
	0000    loadint(x=0,y=0)
	0001    loadint(x=1,y=12)
	0002    loadglobal(x=2,y=19)  // C()
	0003    loadint(x=3,y=1)
	0004    call(x=2,y=1,z=0)
	0005    lt(x=3,y=2,z=1)
	0006    jz(x=7,y=3)
	0013    leave(x=0) */
}


// let fn = fun(x) ? {
// 	if x == lnil ? x = 1
// 	for i in 0..12 ? pf("welcome")
// }

// let fn = fun() ? (0)

// lgi ?= {}
// lgi.lib ?= fn()

// pf(xx)
// let x = 0
// let y = 0
// if x == 0 ? x = 1 else x = 2
// y = x * x
failed = false

let enum test = fun(x,y) ? {
	failed ?= x != y
	if x != y ? {
		pf("failed, expected ", y, ", instead got ", x)
	}
}
main = fun(x,y,z) ? {
	test(stkget(0),"x")
	test(stkget(1),"y")
	test(stkget(2),"z")
	test(stkget(3),1)
	test(stkget(4),2)
	test(stkget(5),3)
}
main("x","y","z",1,2,3)
leave failed/* is a little weird that we use  lang to test lang code */
__logging(false)
let prevdir = pwd()
finally _chdir(prevdir)

let workdir = "code/tests"
pf("running all tests in: ", workdir)

_chdir(workdir)

let sysfile = fopen("tests.ignore","wb")
fpf(sysfile,"test scores:\n")
finally fpf(sysfile,"end of test run");

numfails = 0

let list = listdir(".",fun(file,flags) ? {
	iff file.name:match("*.test.lang") ? {
		leave false
	}
	let _time = clocktime()
	finally pf(" => took: ", timediffs(_time))
	pf("[TEST]: ", file.name)
	/* -- todo: ensure the test does declare
	more globals, store the global count
	beforehand, and then compare with after
	loading the file */
	load file.path
	__logging(false)
	numfails = numfails + 1
	/* failed is a global */
	if failed ? pf("[FAILED]")
	leave true
})


if numfails == 1 ? {
	pf(numfails, " test failed")
} elif numfails > 1 ? {
	pf(numfails, " tests failed")
} else {
	pf("all tests succeeded")
}


test scores:
end of test runlet file = ftemp() finally fclose(file)
let test = {"x"=1,"y"={
	"x"=1,
	"y"=2,
}}
test:unload(file)
pf("size: ",fsize(file));
let data = freadall(file)
pf("data: ",data);
let x = loadexpr(data)
pf(x)
