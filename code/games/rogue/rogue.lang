// if "Hello"[0] != 'H' ? pf("error")
// if "Hello"[4] != 'o' ? pf("error")
__logging(false)
load "code/games/lgi.lang"
if _chdir("code/games/rogue") ? {
	pf("invalid pwd: ", pwd())
	leave false
}
/* this is done at runtime, which
is not the greatest thing */
load "vec.lang"
load "rnd.lang"
load "font.lang"

LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)
/* these are world directions, name as what
they look to the user */
NW = vec3(0,1,0)
NE = vec3(1,0,0)
SW = vec3(-1,0,0)
SE = vec3(0,-1,0)
TILESET_ROWLEN =  11
TILE_SLOTDIMEN =  32
TILE_DRAWDIMEN = 128
ISO_XSKEW = .50
ISO_YSKEW = .25
ISO_XSCALE = TILE_DRAWDIMEN * ISO_XSKEW
ISO_YSCALE = TILE_DRAWDIMEN * ISO_YSKEW
/* all critters are on a singular table,
indexed by position in world */
critters = {}
World = {}
WorldSide = 16
WorldSize = WorldSide*WorldSide*WorldSide
camera = {
	"xyz" = vec3(0,0,0)
}
AIR    = 1000
DIRT   = 0
GRASS  = 23
FLOWER = 42
OAK    = 30
LEAF   = 40
TRUNK  = 48
WATER  = 110
toworldid = fun(x,y,z) ? (WorldSide*WorldSide*ntoi(z) + WorldSide*ntoi(y) + ntoi(x))
toworldid3 = fun(xyz) ? toworldid(xyz.x,xyz.y,xyz.z)
gettileid = fun(x,y,z) ? (World[toworldid(x,y,z)])
settileid = fun(tileid,x,y,z) ? {World[toworldid(x,y,z)] = tileid}
gettileid3 = fun(xyz) ? gettileid(xyz.x,xyz.y,xyz.z)
settileid3 = fun(id,xyz) ? settileid(id,xyz.x,xyz.y,xyz.z)

World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
for i in 0..WorldSide*WorldSide/2 ? {
	settileid(GRASS,rnd(0,16),rnd(0,16),0)
	settileid(FLOWER,rnd(0,16),rnd(0,16),1)
}

settileid(GRASS,6,6,1)
settileid(GRASS,7,6,2)
settileid(GRASS,8,6,3)
settileid(GRASS,9,6,4)
settileid(GRASS,9,7,4)
settileid(GRASS,9,8,4)
settileid(GRASS,9,9,4)


settileid(GRASS,0,0,1)
settileid(GRASS,0,0,2)
settileid(GRASS,0,0,3)
settileid(GRASS,0,0,4)
settileid(GRASS,0,0,5)
settileid(GRASS,0,0,6)
settileid(GRASS,0,0,7)
settileid(GRASS,0,1,7)
settileid(GRASS,0,2,7)
settileid(GRASS,0,3,7)


lgi_initWindowed(720,512, "rogue")

loadassets = fun() ? {
	let time_ = clocktime()
	finally pf("loaded assets, took ", timediffs(time_))

	pf("loading assets... ")
	textures = {
		"tiles" = lgi_loadtexture("tiles2.png"),
		"stag" = lgi_loadtexture("critter_stag.png"),
		"wolf" = lgi_loadtexture("critter_wolf.png"),
	}
	/* make it so that we can change the default sampler */
	for i in 0..textures:length() ? {
		lgi_setsampler(textures:idx(i),"point")
	}

	loadfont()
}

loadassets()


plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)
plot = fun(x,y,z) ? {
	let xx = x - camera.xyz.x
	let yy = y - camera.xyz.y
	let zz = z - camera.xyz.z
	let xxx = (xx - yy) * ISO_XSCALE
	let yyy = (xx + yy + zz) * ISO_YSCALE
	let wx = xxx + lgi_getSizeX()*.5
	let wy = yyy + lgi_getSizeY()*.5
	leave vec3(wx,wy,0)
}


unplot = fun (x,y,wz) ? {
	let cxyz = camera.xyz
	let cx = cxyz.x
	let cy = cxyz.y
	let cz = cxyz.z
	let xx = (x-lgi_getSizeX()*.5) / (ISO_XSCALE*2)
	let yy = (y-lgi_getSizeY()*.5) / (ISO_YSCALE*2)
	let wx = floor(yy-wz/2. + xx + cx + cz/2)
	let wy = floor(yy-wz/2. - xx + cy + cz/2)
	leave vec3(wx,wy,wz)
}


plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	lgi_drawline(lgi_BLUE,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotline3 = fun(color,x0,y0,z0,x1,y1,z1) ? {
	let p0 = plot(x0,y0,z0)
	let p1 = plot(x1,y1,z1)
	lgi_drawline(color,1,p0.x,p0.y,p1.x,p1.y)
}


plotgrid = fun() ? {
	let color = lgi_BLUE
	color.a = .5
	for z in 0..8 ? {
		plotline3(color,0,0,z,8,0,z)
		plotline3(color,0,0,z,0,8,z)
	}
	for z in 0..1 ? {
		for i in 0..8 ? {
			plotline3(color,0,i,z,8,i,z)
			plotline3(color,i,0,z,i,8,z)
		}
	}
	// color = lgi_RED
	// color.a = .1
	// for y in 0..8 ? {
	// 	for x in 0..8 ? {
	// 		plotline3(color,x,y,0,x,y,8)
	// 	}
	// }
}


plotdebugfacex = fun(xyz,w,h) ? {
	let x = xyz.x, y = xyz.y, z = xyz.z
	plotline3(lgi_BLUE,x,y,z,x,y+w,z)
	plotline3(lgi_BLUE,x,y,z,x,y,z+h)
	plotline3(lgi_BLUE,x,y+w,z+h,x,y,z+h)
	plotline3(lgi_BLUE,x,y+w,z,x,y+w,z+h)
}


plotdebugfacey = fun(xyz,w,h) ? {
	let x = xyz.x, y = xyz.y, z = xyz.z
	plotline3(lgi_BLUE,x,y,z,x+w,y,z)
	plotline3(lgi_BLUE,x,y,z,x,y,z+h)
	plotline3(lgi_BLUE,x+w,y,z+h,x,y,z+h)
	plotline3(lgi_BLUE,x+w,y,z,x+w,y,z+h)
}


plotdebugcube = fun(xyz,sx,sy,sz) ? {
	plotdebugfacex(xyz,sx,sz)
	plotdebugfacey(xyz,sx,sz)
	plotdebugfacex(xyz:add(vec3(sx,0,0)),sx,sz)
	plotdebugfacey(xyz:add(vec3(0,sy,0)),sx,sz)
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	plotline3(lgi_BLUE,x+0,y+0,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+0,z,x+0,y+1,z)
	plotline3(lgi_BLUE,x+1,y+1,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+1,z,x+1,y+1,z)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset x by -1 just so that the
	sprite aligns visually with the grid */
	let p = plot(x-1,y,z)
	let px = p.x
	let py = p.y
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


updatecritterstate = fun(xthis,state) ? {
	if state != xthis.state ? {
		xthis.prevstate = xthis.state
		xthis.state = state
	}
}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


issolid = fun(tile) ? {
	let id = gettileid3(tile)
	leave id != AIR && id != FLOWER
}

makeanim = fun(nkeys,clock) ? {
	let self = {}
	self.nkeys = nkeys
	self.clock = clock
	self.timer = timer
	self.index = 0
	self.state = 0
	self.xtick = fun(xthis) ? {
		if xthis.timer > xthis.clock / xthis.nkeys ? {
			xthis.index = (xthis.index + 1) % xthis.nkeys
			xthis.timer = 0
		}
		xthis.timer = xthis.timer + lgi_deltatime()
	}
	leave self
}


movecritter = fun(xthis,offset) ? {
	if xthis.kind == "dummy" ? {
		pf("warning: dummy critters cannot be moved")
		leave false
	}
	if xthis.transing ? leave false
	xthis.facing = offset:clone()
	let origin = xthis.transtiletarget
	let target = origin:add(offset)
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	let height = xthis.height
	/* 0 floor, 1 jumpable, include the tile past
	the height, because tiles are 1 in depth */
	for z in 2..height+1 ? {
		if issolid(target:add(vec3(0,0,z))) ? {
			leave (false)
		}
	}
	if issolid(target:add(vec3(0,0,1))) ? {
		target = target:add(vec3(0,0,1))
	/* check if we're going to fall */
	} else iff issolid(target) ? {
		/* is the fall too steep, if so bail */
		iff issolid(target:add(vec3(0,0,-1))) ? {
			leave (false)
		}
		target = target:add(vec3(0,0,-1))
	}
	let critter = getcritter(target)
	if critter != nil ? {
		if critter.kind == "dummy" ? {
			if critter.proxy != xthis ? {
				leave (false)
			}
		} else leave (false)
	}

	let facing = xthis.facing
	/* this is to make the game more appealing
	visually, it has to do with rendering quirks */
	if facing:eq(NW) || facing:eq(NE) ? {
		/* reserve the target tile so that
		no other entities can occupy it,
		then swap after the move is done,
		this to avoid rendering the tile
		we're currently over above us,
		which is not really that big a
		problem it just makes the game
		seem as if it is artifact'ing a bit  */
	  	let dummy = newcritter("dummy",target)
	  	dummy.proxy = target
  	} else {
  		/* here just swap immediatly so that
  		way render on top of the tile we're
  		going to move to, when the move is done
  		we swap again with ourselves, so no
  		harm done */
		critters[toworldid3(origin)] = nil
		critters[toworldid3(target)] = xthis
  	}
	xthis.transtileorigin = origin
	xthis.transtiletarget = target
	xthis.transing = true

	/* todo: rename this to systime() */
	xthis.timemoved = clocktime()
	leave true
}


crittercontroller_player = fun(critter) ? {
	if lgi_iskeydown('W') ? movecritter(critter,RIGHT)
	if lgi_iskeydown('D') ? movecritter(critter,DOWN)
	if lgi_iskeydown('A') ? movecritter(critter,UP)
	if lgi_iskeydown('S') ? movecritter(critter,LEFT)
}

critterplotter_dummy = fun(critter) ? {
}
crittercontroller_dummy = fun(critter) ? {
}

crittercontroller_wolf = fun(critter) ? {
	if critter.turntimer < .0 ? {
		critter.turntimer = critter.turnclock
		movecritter(critter,vec3(rnd(-1,2),rnd(-1,2),0))
	}
	critter.turntimer = critter.turntimer - lgi_deltatime()
}


critterplotter_stag = fun(xthis) ? {
	let xyz = xthis.xyz
	let pxy = plot3(xyz)
	let px = pxy.x
	let py = pxy.y
	let w = 32.
	let h = 41.
	let a = h / w
	let s = 128
	px = px - s*.35
	py = py + s*.05
	// lgi_drawQuad(lgi_WHITE,px,py,s,s*a)
	// xanim,8*41
	let yanim = 41*11
	let xanim = 32 * ((xthis.animtimer / .128) % 23)
	let facing = xthis.facing
	let animlabel = xthis.animlabel
	if xthis.transing ? {
		xanim = 32 * ((xthis.animtimer / .032) % 11)
		// animlabel = "walking"
		yanim = 0
		  if facing:eq(SW) ? yanim = 0
		elif facing:eq(SE) ? yanim = 41*1
		elif facing:eq(NW) ? yanim = 41*2
		elif facing:eq(NE) ? yanim = 41*3
		else pf("error")
	} else {
		animlabel = "idle"
		if facing:eq(SW) ? yanim = 41*8
		elif facing:eq(SE) ? yanim = 41*9
		elif facing:eq(NW) ? yanim = 41*10
		elif facing:eq(NE) ? yanim = 41*11
		else pf("error")
	}
	if animlabel != xthis.animlabel ? {
		xthis.animtimer = 0
		xthis.animlabel = animlabel
		pf("switch animation")
	}

	lgi_drawtexture(textures.stag,px,py,s,s*a,xanim,yanim,32,41)
	xthis.animtimer = xthis.animtimer + lgi_deltatime()
}


critterplotter_wolf = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(critter.xyz).{"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y

	let xanim = 64 * ((lgi_time() / .128) % 4)
	let w = 64.
	let h = 64.
	let a = h / w
	let s = 256
	let v = s*a
	px = px - s*.5
	py = py - v*.2
	// lgi_drawQuad(lgi_WHITE,px,py,256,v)
	lgi_drawtexture(textures.wolf,px,py,s,v,xanim,64*12,64,64)
}


newcritter = fun(kind,xyz) ? {
	kind ?= "dummy"
	let xthis = {}
	updatecritterstate(xthis,"idle")
	xthis.kind = kind
	xthis.xyz = xyz
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	xthis.ticked = false
	xthis.turnclock = 2.
	xthis.turntimer = 2.
	xthis.timemoved = 0
	xthis.moveclock = .256
	xthis.transtileorigin = vec3()
	xthis.transtiletarget = xyz
	xthis.transing = false
	xthis.height = 3
	xthis.animtimer = 0.
	xthis.animlabel = "idle"
	xthis.facing = NW
	xthis.controller = crittercontroller_dummy
	xthis.plotter = critterplotter_dummy
	let already = critters[toworldid3(xyz)]
	if already != nil && already != "dummy" ? {
		pf("error, critter already here")
	} else critters[toworldid3(xyz)] = xthis
	leave xthis
}


newwolf = fun(xyz) ? {
	let xthis = newcritter("wolf",xyz)
	xthis.controller = crittercontroller_wolf
	xthis.plotter = critterplotter_wolf
	leave xthis
}


newstag = fun(xyz) ? {
	let xthis = newcritter("stag",xyz)
	xthis.controller = crittercontroller_player
	xthis.plotter = critterplotter_stag
	leave xthis
}


tickcritter = fun(xthis) ? {
	if xthis.kind == "dummy" ? leave ()
	xthis.ticked = xthis.ticked + 1
	// if xthis.ticked > 1 ? pf("ticked: ", xthis.ticked)
	if xthis.ticked - 1 != 0 ? leave ()
	xthis.ticked = true
	xthis.controller(xthis)
	let diffs = timediffs(xthis.timemoved)
	if xthis.transing ? {
		if diffs < xthis.moveclock ? {
			let movedelta = diffs / xthis.moveclock
			xthis.xyz = xthis.transtileorigin:lerp(xthis.transtiletarget,movedelta)
		} else {
			xthis.transing = false
			let origin = toworldid3(xthis.transtileorigin)
			if critters[origin] != nil ? {
				if critters[origin] == xthis ? {
					critters[origin] = nil
				} elif critters[origin].kind == "dummy" ? {
					if critters[origin].proxy == xthis ? {
						critters[origin] = nil
					}
				}
			}
			critters[toworldid3(xthis.transtiletarget)] = xthis
		}
	}
}


plotcritter = fun(xthis) ? {
	xthis.ticked = false
	xthis.plotter(xthis)
	if showgrid ? plotdebugcube(xthis.xyz,1,1,xthis.height)
}


for i in 0..4 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	newwolf(vec3(rnd(1,12),rnd(1,12),0))
}

wolf = newstag(vec3(0,2,0))

fortilesinplotorder = fun(per) ? {
	let numvis = 16
	for y in 0..numvis ? {
		let iy = numvis-1-y
		for x in 0..numvis ? {
			let ix = numvis-1-x
			for z in 0..numvis ? {
				per(ix,iy,z)
			}
		}
	}
}


showgrid = false
trackplayer = true
/* todo: we can do lighting trick by
rendering tiles less times */
do {
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()

	if lgi_testKey('G') ? showgrid = showgrid == false
	if lgi_testKey('T') ? trackplayer = trackplayer == false

	if trackplayer ? {
		camera.xyz = wolf.xyz:clone()
	}
	// pf(camerax, ", ", cameray)
	// if lgi_testKey('W') ? move(UP)
	// if lgi_testKey('D') ? move(RIGHT)
	// if lgi_testKey('A') ? move(LEFT)
	// if lgi_testKey('S') ? move(DOWN)

	lgi_clearBackground();

	fortilesinplotorder(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})

	fortilesinplotorder(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
		if z > 0 ? {
			let critter = critters[toworldid(x,y,z-1)]
			if critter != nil ? {
				plotcritter(critter)
			}
		}
	})

	/* todo: why don't we have breakstatements yet */
	let looping = true
	let level = 0
	let hit = nil
	while looping == true ? {
		let world = unplot(xcursor,ycursor,level)
		if world.x < 0 ? looping = false
		if world.y < 0 ? looping = false
		if level > 128 ? __debugbreak()
		if looping == true ? {
			level = level + 1
			if issolid(world) ? hit = world
		}
	}
	plottext(0,0,"You are here, you!")
	if hit != nil ? plottileoutline(hit)
	if showgrid ? plotgrid()
	if showgrid ? plotdebugcube(vec3(0,0,0),12,12,12)
	if lgi_isclick(1) ? {
		if hit != nil ? settileid3(AIR,hit)
	} else
	if lgi_isclick(0) ? {
		if hit != nil ? settileid3(TRUNK,hit:add(vec3(0,0,1)))
	}
	if lgi_isbuttondown(0) ? {
	} elif lgi_isbuttondown(1) ? {
	}
} while lgi_tick()





