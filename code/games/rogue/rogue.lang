__logging(false)

load "code/games/lgi.lang"

if _chdir("code/games/rogue") ? {
	pf("invalid pwd: ", pwd())
	leave false
}

/* this is done at runtime, which
is not the greatest thing */
load "vec.lang"
load "rnd.lang"


let enum {
	LEFT  = vec3(-1, 0, 0),
	RIGHT = vec3( 1, 0, 0),
	UP    = vec3( 0, 1, 0),
	DOWN  = vec3( 0,-1, 0),
}


// let enum {
// 	TILESET_ROWLEN =  10,
// 	TILE_SLOTDIMEN =  18,
// 	TILE_DRAWDIMEN = 128,
// }

let enum {
	TILESET_ROWLEN =  11,
	TILE_SLOTDIMEN =  32,
	TILE_DRAWDIMEN = 128,
	ISO_XSKEW = .50,
	ISO_YSKEW = .25,
	ISO_XSCALE = TILE_DRAWDIMEN * ISO_XSKEW,
	ISO_YSCALE = TILE_DRAWDIMEN * ISO_YSKEW,
}

/* all critters are on a singular table,
indexed by position in world */
critters = {}
World = {}


WorldSide = 16
WorldSize = WorldSide*WorldSide*WorldSide


let camera = {
	"xyz" = vec3(0,0,0)
}



// let enum {
// 	GRASS  = 0,
// 	DIRT   = 6,
// 	AIR    = 9,
// 	WATER  = 23,
// 	OAK    = 30,
// 	LEAF   = 40,
// }

AIR    = 1000
DIRT   = 0
GRASS  = 23
FLOWER = 42
OAK    = 30
LEAF   = 40
TRUNK  = 48
WATER  = 110

toworldid = fun(x,y,z) ? (WorldSide*WorldSide*z + WorldSide * y + x)
toworldid3 = fun(xyz) ? toworldid(xyz.x,xyz.y,xyz.z)
gettileid = fun(x,y,z) ? (World[toworldid(x,y,z)])
settileid = fun(tileid,x,y,z) ? {World[toworldid(x,y,z)] = tileid}
gettileid3 = fun(xyz) ? gettileid(xyz.x,xyz.y,xyz.z)
settileid3 = fun(id,xyz) ? settileid(id,xyz.x,xyz.y,xyz.z)

World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
for i in 0..WorldSide*WorldSide/2 ? {
	settileid(GRASS,rnd(0,16),rnd(0,16),0)
	settileid(FLOWER,rnd(0,16),rnd(0,16),1)
}

settileid(GRASS,6,6,1)
settileid(GRASS,7,6,2)
settileid(GRASS,8,6,3)
settileid(GRASS,9,6,4)
settileid(GRASS,9,7,4)
settileid(GRASS,9,8,4)
settileid(GRASS,9,9,4)


settileid(GRASS,0,0,1)
settileid(GRASS,0,0,2)
settileid(GRASS,0,0,3)
settileid(GRASS,0,0,4)
settileid(GRASS,0,0,5)
settileid(GRASS,0,0,6)
settileid(GRASS,0,0,7)
settileid(GRASS,0,1,7)
settileid(GRASS,0,2,7)
settileid(GRASS,0,3,7)





// let addtree = fun(x,y) ? {
// 	settileid(OAK,x,y,1)
// 	settileid(OAK,x,y,2)
// 	settileid(LEAF,x,y,3)
// 	settileid(LEAF,x,y,4)
// 	settileid(LEAF,x+1,y,3)
// 	settileid(LEAF,x-1,y,3)
// 	settileid(LEAF,x,y+1,3)
// 	settileid(LEAF,x,y-1,3)
// }
// addtree(1,1)


lgi_initWindowed(720,512, "rogue")

textures = {
	"tiles" = lgi_loadtexture("tiles2.png"),
	"stag" = lgi_loadtexture("critter_stag.png"),
	"wolf" = lgi_loadtexture("critter_wolf.png"),
}


/* make it so that we change the default sampler */
for i in 0..textures:length() ? {
	lgi_setsampler(textures:idx(i),"point")
}



raycast = fun (x,y) ? {
	/* todo: figure out the starting tile */
	for z in 0..8 ? {
		let p = unplot(x,y,8-1-z)
		if gettileid3(p) != AIR ? leave p
	}
	leave nil
}


plot = fun(x,y,z) ? {
	let xx = x - camera.xyz.x
	let yy = y - camera.xyz.y
	let zz = z - camera.xyz.z
	let xxx = (xx - yy) * ISO_XSCALE
	let yyy = (xx + yy + zz) * ISO_YSCALE
	let wx = xxx + lgi_getSizeX()*.5
	let wy = yyy + lgi_getSizeY()*.5
	leave vec3(wx,wy,0)
}


plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)


unplot = fun (x,y,z) ? {
	let xview = x - lgi_getSizeX() * .5
	let yview = y - lgi_getSizeY() * .5
	let xx = xview / (ISO_XSCALE*2)
	let yy = yview / (ISO_YSCALE*2)
	let wx = yy + xx + camera.xyz.x
	let wy = yy - xx + camera.xyz.y
	let wz = yview / ISO_YSCALE - xx - yy
	leave vec3(wx,wy,wz):floor()
}


plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	lgi_drawline(lgi_BLUE,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotline3 = fun(color,x0,y0,z0,x1,y1,z1) ? {
	let xy0 = plot(x0,y0,z0)
	let xy1 = plot(x1,y1,z1)
	lgi_drawline(color,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotgrid = fun() ? {
	let color = lgi_BLUE
	color.a = .5
	for z in 0..8 ? {
		for i in 0..8 ? {
			plotline3(color,0,i,z,8,i,z)
			plotline3(color,i,0,z,i,8,z)
		}
	}
	color = lgi_RED
	color.a = .1
	for y in 0..8 ? {
		for x in 0..8 ? {
			plotline3(color,x,y,0,x,y,8)
		}
	}
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	plotline3(lgi_BLUE,x+0,y+0,0,x+1,y+0,0)
	plotline3(lgi_BLUE,x+0,y+0,0,x+0,y+1,0)
	plotline3(lgi_BLUE,x+1,y+1,0,x+1,y+0,0)
	plotline3(lgi_BLUE,x+0,y+1,0,x+1,y+1,0)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset x by -1 just so that sprite aligns
	visually with the grid */
	let p = plot(x-1,y,z)
	let px = p.x
	let py = p.y
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


updatecritterstate = fun(xthis,state) ? {
	if state != xthis.state ? {
		xthis.prevstate = xthis.state
		xthis.state = state
	}
}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


issolid = fun(tile) ? {
	let id = gettileid3(tile)
	leave id != AIR && id != FLOWER
}


movecritter = fun(xthis,offset) ? {
	let origin = xthis.xyzmov
	let target = origin:add(offset)
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	if issolid(target:add(vec3(0,0,2))) ? {
		leave (false)
	} elif issolid(target:add(vec3(0,0,1))) ? {
		target = target:add(vec3(0,0,1))
	/* check if we're going to fall */
	} else iff issolid(target) ? {
		/* is the fall too steep, if so bail */
		iff issolid(target:add(vec3(0,0,-1))) ? {
			leave (false)
		}
		target = target:add(vec3(0,0,-1))
	}
	let critter = getcritter(target)
	if critter != nil ? leave false
	critters[toworldid3(origin)] = nil
	critters[toworldid3(target)] = xthis
	xthis.xyzmov = target
	xthis.ismoving = true
	leave true
}


crittercontroller_player = fun(critter) ? {
	if lgi_testKey('W') ? movecritter(critter,RIGHT)
	if lgi_testKey('D') ? movecritter(critter,DOWN)
	if lgi_testKey('A') ? movecritter(critter,UP)
	if lgi_testKey('S') ? movecritter(critter,LEFT)
}


crittercontroller_dummy = fun(critter) ? {
	if critter.turntimer < .0 ? {
		critter.turntimer = critter.turnclock
		movecritter(critter,vec3(rnd(-1,2),rnd(-1,2),0))
		// if gettileid3(critter.xyz) == GRASS ? {
		// 	updatecritterstate(critter,"grazing")
		// } else {
		// 	updatecritterstate(critter,critter.prevstate)
		// }
	}
	critter.turntimer = critter.turntimer - lgi_deltatime()
}


critterplotter_stag = fun(xthis) ? {
	let xyz = xthis.xyz
	let pxy = plot3(xyz)
	let px = pxy.x
	let py = pxy.y
	let xanim = 32 * ((lgi_time() / .128) % 23)
	// if xthis.state == "grazing" ? {
	// 	xanim = 32 * (21 + (lgi_time() / .512) % 4)
	// }
	let w = 32.
	let h = 41.
	let a = h / w
	let s = 128

	px = px - s*.35
	py = py + s*.05
	// lgi_drawQuad(lgi_WHITE,px,py,s,s*a)
	// xanim,8*41
	lgi_drawtexture(textures.stag,px,py,s,s*a,xanim,41*11,32,41)
}


critterplotter_wolf = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(critter.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y

	let xanim = 64 * ((lgi_time() / .128) % 4)
	let w = 64.
	let h = 64.
	let a = h / w
	let s = 256
	let v = s*a
	px = px - s*.5
	py = py - v*.2
	// lgi_drawQuad(lgi_WHITE,px,py,256,v)
	lgi_drawtexture(textures.wolf,px,py,s,v,xanim,64*12,64,64)
}


newcritter = fun(xyz) ? {
	let xthis = {}
	updatecritterstate(xthis,"idle")
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	xthis.ticked = false
	xthis.turnclock = 2.
	xthis.turntimer = 2.
	xthis.moveclock = .256
	xthis.movetimer = .0
	xthis.ismoving = false
	xthis.xyz = xyz
	xthis.xyzmov = xyz
	xthis.controller = crittercontroller_dummy
	xthis.plotter = critterplotter_wolf

	critters[toworldid3(xyz)] = xthis
	leave xthis
}


newstag = fun(xyz) ? {
	let xthis = newcritter(xyz)
	xthis.controller = crittercontroller_player
	xthis.plotter = critterplotter_stag
	leave xthis
}


tickcritter = fun(xthis) ? {
	if xthis.ticked ? leave ()
	xthis.ticked = true
	xthis.controller(xthis)
	if xthis.movetimer >= xthis.moveclock ? {
		xthis.ismoving = false
		xthis.movetimer = 0
	}
	if xthis.ismoving ? {
		let movedelta = xthis.movetimer / xthis.moveclock
		xthis.xyz = xthis.xyz:lerp(xthis.xyzmov,movedelta)
		xthis.movetimer = xthis.movetimer + lgi_deltatime()
	}
}


plotcritter = fun(xthis) ? {
	xthis.ticked = false
	xthis.plotter(xthis)
	// plottileoutline(xthis.xyz)
}


for i in 0..8 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	newcritter(vec3(rnd(1,12),rnd(1,12),0))
}

wolf = newstag(vec3(0,2,0))

fortilesinplotorder = fun(per) ? {
	for y in 0..12 ? {
		let iy = 12-1-y
		for x in 0..12 ? {
			let ix = 12-1-x
			for z in 0..12 ? {
				per(ix,iy,z)
			}
		}
	}
}


showgrid = false
/* todo: we can do lighting trick by
rendering tiles less times */
do {
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()

	camera.xyz = wolf.xyz:clone()
	// pf(camerax, ", ", cameray)
	// if lgi_testKey('W') ? move(UP)
	// if lgi_testKey('D') ? move(RIGHT)
	// if lgi_testKey('A') ? move(LEFT)
	// if lgi_testKey('S') ? move(DOWN)

	lgi_clearBackground();

	fortilesinplotorder(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})

	fortilesinplotorder(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
		if z > 0 ? {
			let critter = critters[toworldid(x,y,z-1)]
			if critter != nil ? {
				plotcritter(critter)
			}
		}
	})

	let world = unplot(xcursor,ycursor,0)
	plottileoutline(world)

	if lgi_testKey('G') ? {
		showgrid = showgrid == false
	}
	if showgrid ? {
		plotgrid()
	}

	if lgi_isbuttondown(0) ? {
		pf(world)
		// let hit = raycast(xcursor,ycursor)
		// if hit != nil ? {
		// 	plottileoutline(hit)
		// 	settileid3(TRUNK,hit:add(vec3(0,0,1)))
		// }
		// settileid3(TRUNK,world)
	} elif lgi_isbuttondown(1) ? {

	}
} while lgi_tick()





