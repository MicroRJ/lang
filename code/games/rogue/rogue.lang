__logging(false)

load "code/games/lgi.lang"

if _chdir("code/games/rogue") ? {
	pf("invalid pwd: ", pwd())
	leave false
}

/* this is done at runtime, which
is not the greatest thing */
load "vec.lang"
load "rnd.lang"


LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)

/* these are world directions, name as what
they look to the user */
NW = vec3(0,1,0)
NE = vec3(1,0,0)
SW = vec3(-1,0,0)
SE = vec3(0,-1,0)



// let enum {
// 	TILESET_ROWLEN =  10,
// 	TILE_SLOTDIMEN =  18,
// 	TILE_DRAWDIMEN = 128,
// }

let enum {
	TILESET_ROWLEN =  11,
	TILE_SLOTDIMEN =  32,
	TILE_DRAWDIMEN = 128,
	ISO_XSKEW = .50,
	ISO_YSKEW = .25,
	ISO_XSCALE = TILE_DRAWDIMEN * ISO_XSKEW,
	ISO_YSCALE = TILE_DRAWDIMEN * ISO_YSKEW,
}

/* all critters are on a singular table,
indexed by position in world */
critters = {}
World = {}


WorldSide = 16
WorldSize = WorldSide*WorldSide*WorldSide


let camera = {
	"xyz" = vec3(0,0,0)
}



// let enum {
// 	GRASS  = 0,
// 	DIRT   = 6,
// 	AIR    = 9,
// 	WATER  = 23,
// 	OAK    = 30,
// 	LEAF   = 40,
// }

AIR    = 1000
DIRT   = 0
GRASS  = 23
FLOWER = 42
OAK    = 30
LEAF   = 40
TRUNK  = 48
WATER  = 110

toworldid = fun(x,y,z) ? (WorldSide*WorldSide*z + WorldSide * y + x)
toworldid3 = fun(xyz) ? toworldid(xyz.x,xyz.y,xyz.z)
gettileid = fun(x,y,z) ? (World[toworldid(x,y,z)])
settileid = fun(tileid,x,y,z) ? {World[toworldid(x,y,z)] = tileid}
gettileid3 = fun(xyz) ? gettileid(xyz.x,xyz.y,xyz.z)
settileid3 = fun(id,xyz) ? settileid(id,xyz.x,xyz.y,xyz.z)

World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
for i in 0..WorldSide*WorldSide/2 ? {
	settileid(GRASS,rnd(0,16),rnd(0,16),0)
	settileid(FLOWER,rnd(0,16),rnd(0,16),1)
}

settileid(GRASS,6,6,1)
settileid(GRASS,7,6,2)
settileid(GRASS,8,6,3)
settileid(GRASS,9,6,4)
settileid(GRASS,9,7,4)
settileid(GRASS,9,8,4)
settileid(GRASS,9,9,4)


settileid(GRASS,0,0,1)
settileid(GRASS,0,0,2)
settileid(GRASS,0,0,3)
settileid(GRASS,0,0,4)
settileid(GRASS,0,0,5)
settileid(GRASS,0,0,6)
settileid(GRASS,0,0,7)
settileid(GRASS,0,1,7)
settileid(GRASS,0,2,7)
settileid(GRASS,0,3,7)





// let addtree = fun(x,y) ? {
// 	settileid(OAK,x,y,1)
// 	settileid(OAK,x,y,2)
// 	settileid(LEAF,x,y,3)
// 	settileid(LEAF,x,y,4)
// 	settileid(LEAF,x+1,y,3)
// 	settileid(LEAF,x-1,y,3)
// 	settileid(LEAF,x,y+1,3)
// 	settileid(LEAF,x,y-1,3)
// }
// addtree(1,1)


lgi_initWindowed(720,512, "rogue")

loadassets = fun() ? {
	let time_ = clocktime()
	finally pf("loaded assets, took ", timediffs(time_))

	pf("loading assets... ")
	textures = {
		"tiles" = lgi_loadtexture("tiles2.png"),
		"stag" = lgi_loadtexture("critter_stag.png"),
		"wolf" = lgi_loadtexture("critter_wolf.png"),
	}
	/* make it so that we can change the default sampler */
	for i in 0..textures:length() ? {
		lgi_setsampler(textures:idx(i),"point")
	}
}
loadassets()


plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)
plot = fun(x,y,z) ? {
	let xx = x - camera.xyz.x
	let yy = y - camera.xyz.y
	let zz = z - camera.xyz.z
	let xxx = (xx - yy) * ISO_XSCALE
	let yyy = (xx + yy + zz) * ISO_YSCALE
	let wx = xxx + lgi_getSizeX()*.5
	let wy = yyy + lgi_getSizeY()*.5
	leave vec3(wx,wy,0)
}


/* todo: I have to keep messing around with this:
this will only work on one of the planes */
unskew = fun (x,y,z) ? {
	let xx = (x-lgi_getSizeX()*.5) / (ISO_XSKEW*2)
	let yy = (y-lgi_getSizeY()*.5) / (ISO_YSKEW*2)
	let wx = yy + xx + camera.xyz.x*TILE_DRAWDIMEN
	let wy = yy - xx + camera.xyz.y*TILE_DRAWDIMEN
	leave vec3(wx,wy)
	/* convert from isometric projection to worldspace */
	let xview = x - lgi_getSizeX() * .5
	let yview = y - lgi_getSizeY() * .5
	let xx = xview / (ISO_XSKEW*2)
	let yy = yview / (ISO_YSKEW*2)
	let wx = yy + xx + camera.xyz.x*TILE_DRAWDIMEN
	let wy = yy - xx + camera.xyz.y*TILE_DRAWDIMEN
	/* now we pretend there's an imaginary barrier
	between the world and the camera, the transform
	for this space is this: */
	let wwx = wx - wy
	let wwy = wy/ISO_YSKEW
	/* now we've projected onto the barrier */
	let wwz = wwy/(TILE_DRAWDIMEN*2)
	leave vec3(wwx,wwy,wwy)
}


unplot = fun (x,y,z) ? {
	let xview = x - lgi_getSizeX() * .5
	let yview = y - lgi_getSizeY() * .5
	let xx = xview / (ISO_XSCALE*2)
	let yy = yview / (ISO_YSCALE*2)
	let wx = floor(yy + xx + camera.xyz.x)
	let wy = floor(yy - xx + camera.xyz.y)
	let wz = z
	leave vec3(wx,wy,wz)
}


plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	lgi_drawline(lgi_BLUE,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotline3 = fun(color,x0,y0,z0,x1,y1,z1) ? {
	let p0 = plot(x0,y0,z0)
	let p1 = plot(x1,y1,z1)
	lgi_drawline(color,1,p0.x,p0.y,p1.x,p1.y)
}


plotgrid = fun() ? {
	let color = lgi_BLUE
	color.a = .5
	for z in 0..8 ? {
		plotline3(color,0,0,z,8,0,z)
		plotline3(color,0,0,z,0,8,z)
	}
	for z in 0..1 ? {
		for i in 0..8 ? {
			plotline3(color,0,i,z,8,i,z)
			plotline3(color,i,0,z,i,8,z)
		}
	}
	// color = lgi_RED
	// color.a = .1
	// for y in 0..8 ? {
	// 	for x in 0..8 ? {
	// 		plotline3(color,x,y,0,x,y,8)
	// 	}
	// }
}


plotdebugfacex = fun(xyz,w,h) ? {
	let x = xyz.x, y = xyz.y, z = xyz.z
	plotline3(lgi_BLUE,x,y,z,x,y+w,z)
	plotline3(lgi_BLUE,x,y,z,x,y,z+h)
	plotline3(lgi_BLUE,x,y+w,z+h,x,y,z+h)
	plotline3(lgi_BLUE,x,y+w,z,x,y+w,z+h)
}


plotdebugfacey = fun(xyz,w,h) ? {
	let x = xyz.x, y = xyz.y, z = xyz.z
	plotline3(lgi_BLUE,x,y,z,x+w,y,z)
	plotline3(lgi_BLUE,x,y,z,x,y,z+h)
	plotline3(lgi_BLUE,x+w,y,z+h,x,y,z+h)
	plotline3(lgi_BLUE,x+w,y,z,x+w,y,z+h)
}


plotdebugcube = fun(xyz,sx,sy,sz) ? {
	plotdebugfacex(xyz,sx,sz)
	plotdebugfacey(xyz,sx,sz)
	plotdebugfacex(xyz:add(vec3(sx,0,0)),sx,sz)
	plotdebugfacey(xyz:add(vec3(0,sy,0)),sx,sz)
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	plotline3(lgi_BLUE,x+0,y+0,0,x+1,y+0,0)
	plotline3(lgi_BLUE,x+0,y+0,0,x+0,y+1,0)
	plotline3(lgi_BLUE,x+1,y+1,0,x+1,y+0,0)
	plotline3(lgi_BLUE,x+0,y+1,0,x+1,y+1,0)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset x by -1 just so that sprite aligns
	visually with the grid */
	let p = plot(x-1,y,z)
	let px = p.x
	let py = p.y
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


updatecritterstate = fun(xthis,state) ? {
	if state != xthis.state ? {
		xthis.prevstate = xthis.state
		xthis.state = state
	}
}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


issolid = fun(tile) ? {
	let id = gettileid3(tile)
	leave id != AIR && id != FLOWER
}

makeanim = fun(nkeys,clock) ? {
	let self = {}
	self.nkeys = nkeys
	self.clock = clock
	self.timer = timer
	self.index = 0
	self.state = 0
	self.xtick = fun(xthis) ? {
		if xthis.timer > xthis.clock / xthis.nkeys ? {
			xthis.index = (xthis.index + 1) % xthis.nkeys
			xthis.timer = 0
		}
		xthis.timer = xthis.timer + lgi_deltatime()
	}
	leave self
}


movecritter = fun(xthis,offset) ? {
	if xthis.ismoving ? leave false
	xthis.facing = offset:clone()
	let origin = xthis.xyzmov
	let target = origin:add(offset)
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	let height = xthis.height
	/* 0 floor, 1 jumpable, include the tile past
	the height, because tiles are 1 in depth */
	for z in 2..height+1 ? {
		if issolid(target:add(vec3(0,0,z))) ? {
			leave (false)
		}
	}
	if issolid(target:add(vec3(0,0,1))) ? {
		target = target:add(vec3(0,0,1))
	/* check if we're going to fall */
	} else iff issolid(target) ? {
		/* is the fall too steep, if so bail */
		iff issolid(target:add(vec3(0,0,-1))) ? {
			leave (false)
		}
		target = target:add(vec3(0,0,-1))
	}
	let critter = getcritter(target)
	if critter != nil ? leave false
	critters[toworldid3(origin)] = nil
	critters[toworldid3(target)] = xthis
	xthis.moveorigin = xthis.xyz:clone()
	xthis.xyzmov = target
	xthis.ismoving = true
	/* todo: rename this to systime() */
	xthis.timemoved = clocktime()
	leave true
}


crittercontroller_player = fun(critter) ? {
	if lgi_iskeydown('W') ? movecritter(critter,RIGHT)
	if lgi_iskeydown('D') ? movecritter(critter,DOWN)
	if lgi_iskeydown('A') ? movecritter(critter,UP)
	if lgi_iskeydown('S') ? movecritter(critter,LEFT)
}


crittercontroller_dummy = fun(critter) ? {
	if critter.turntimer < .0 ? {
		critter.turntimer = critter.turnclock
		movecritter(critter,vec3(rnd(-1,2),rnd(-1,2),0))
		// if gettileid3(critter.xyz) == GRASS ? {
		// 	updatecritterstate(critter,"grazing")
		// } else {
		// 	updatecritterstate(critter,critter.prevstate)
		// }
	}
	critter.turntimer = critter.turntimer - lgi_deltatime()
}


critterplotter_stag = fun(xthis) ? {
	let xyz = xthis.xyz
	let pxy = plot3(xyz)
	let px = pxy.x
	let py = pxy.y
	// if xthis.state == "grazing" ? {
	// 	xanim = 32 * (21 + (lgi_time() / .512) % 4)
	// }
	let w = 32.
	let h = 41.
	let a = h / w
	let s = 128

	px = px - s*.35
	py = py + s*.05
	// lgi_drawQuad(lgi_WHITE,px,py,s,s*a)
	// xanim,8*41
	let yanim = 41*11
	let xanim = 32 * ((xthis.animtimer / .128) % 23)
	let facing = xthis.facing
	let animlabel = xthis.animlabel
	if xthis.ismoving ? {
		xanim = 32 * ((xthis.animtimer / .032) % 11)
		// animlabel = "walking"
		yanim = 0
		  if facing:eq(SW) ? yanim = 0
		elif facing:eq(SE) ? yanim = 41*1
		elif facing:eq(NW) ? yanim = 41*2
		elif facing:eq(NE) ? yanim = 41*3
		else pf("error")
	} else {
		animlabel = "idle"
		if facing:eq(SW) ? yanim = 41*8
		elif facing:eq(SE) ? yanim = 41*9
		elif facing:eq(NW) ? yanim = 41*10
		elif facing:eq(NE) ? yanim = 41*11
		else pf("error")
	}
	if animlabel != xthis.animlabel ? {
		xthis.animtimer = 0
		xthis.animlabel = animlabel
		pf("switch animation")
	}

	lgi_drawtexture(textures.stag,px,py,s,s*a,xanim,yanim,32,41)
	xthis.animtimer = xthis.animtimer + lgi_deltatime()
}


critterplotter_wolf = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(critter.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y

	let xanim = 64 * ((lgi_time() / .128) % 4)
	let w = 64.
	let h = 64.
	let a = h / w
	let s = 256
	let v = s*a
	px = px - s*.5
	py = py - v*.2
	// lgi_drawQuad(lgi_WHITE,px,py,256,v)
	lgi_drawtexture(textures.wolf,px,py,s,v,xanim,64*12,64,64)
}


newcritter = fun(xyz) ? {
	let xthis = {}
	updatecritterstate(xthis,"idle")
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	xthis.xyz = xyz
	xthis.ticked = false
	xthis.turnclock = 2.
	xthis.turntimer = 2.
	xthis.timemoved = 0
	xthis.moveclock = .256
	xthis.moveorigin = vec3()
	xthis.xyzmov = xyz
	xthis.ismoving = false
	xthis.height = 3
	xthis.animtimer = 0.
	xthis.animlabel = "idle"
	xthis.facing = NW
	xthis.controller = crittercontroller_dummy
	xthis.plotter = critterplotter_wolf

	critters[toworldid3(xyz)] = xthis
	leave xthis
}


newstag = fun(xyz) ? {
	let xthis = newcritter(xyz)
	xthis.controller = crittercontroller_player
	xthis.plotter = critterplotter_stag
	leave xthis
}


tickcritter = fun(xthis) ? {
	if xthis.ticked ? leave ()
	xthis.ticked = true
	xthis.controller(xthis)
	let movetimediffs = timediffs(xthis.timemoved)
	if movetimediffs >= xthis.moveclock ? {
		xthis.ismoving = false
	}
	if xthis.ismoving ? {
		let movedelta = movetimediffs / xthis.moveclock
		xthis.xyz = xthis.moveorigin:lerp(xthis.xyzmov,movedelta)
	}
}


plotcritter = fun(xthis) ? {
	xthis.ticked = false
	xthis.plotter(xthis)
	if showgrid ? plotdebugcube(xthis.xyz,1,1,xthis.height)
}


for i in 0..8 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	newcritter(vec3(rnd(1,12),rnd(1,12),0))
}

wolf = newstag(vec3(0,2,0))

fortilesinplotorder = fun(per) ? {
	for y in 0..12 ? {
		let iy = 12-1-y
		for x in 0..12 ? {
			let ix = 12-1-x
			for z in 0..12 ? {
				per(ix,iy,z)
			}
		}
	}
}


showgrid = false
/* todo: we can do lighting trick by
rendering tiles less times */
do {
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()

	camera.xyz = wolf.xyz:clone()
	// pf(camerax, ", ", cameray)
	// if lgi_testKey('W') ? move(UP)
	// if lgi_testKey('D') ? move(RIGHT)
	// if lgi_testKey('A') ? move(LEFT)
	// if lgi_testKey('S') ? move(DOWN)

	lgi_clearBackground();

	fortilesinplotorder(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})

	fortilesinplotorder(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
		if z > 0 ? {
			/* this is fine, but the problem is that
			that when walking around, the critter will
			switch tiles, and the animation will make
			seem as if the tile were the critter is
			currently on is on top of the critter,
			since the critter has to animate there,
			maybe we could reserve the tile, and then
			once the critter has finished moving there
			switch it around in the table.. */
			let critter = critters[toworldid(x,y,z-1)]
			if critter != nil ? {
				plotcritter(critter)
			}
		}
	})

	let world = unplot(xcursor,ycursor,0)
	plottileoutline(world)

	if lgi_testKey('G') ? {
		showgrid = showgrid == false
	}

	if showgrid ? plotgrid()
	if showgrid ? plotdebugcube(vec3(0,0,0),12,12,12)

	if lgi_isbuttondown(0) ? {
		pf(unskew(xcursor,ycursor,0))
	} elif lgi_isbuttondown(1) ? {
	}
} while lgi_tick()





