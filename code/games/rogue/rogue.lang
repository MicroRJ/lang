__logging(false)

load "code/games/lgi.lang"

if _chdir("code/games/rogue") ? {
	pf("invalid pwd: ", pwd())
	leave false
}

lerp = fun(x,y,z) ? (y + x * (z - y))
unlerp = fun(x,y,z) ? ((x - y) / (z - y))
map = fun(x,y,z,w,v) ? lerp(unlerp(x,y,z),w,v)

__vec2_add = fun(c) ? vec2(this.x+c.x,this.y+c.y)
__vec2_sub = fun(c) ? vec2(this.x-c.x,this.y-c.y)
__vec2_mul = fun(c) ? vec2(this.x*c.x,this.y*c.y)
__vec2_div = fun(c) ? vec2(this.x/c.x,this.y/c.y)

vec2 = fun(x,y) ? {
	let v = {"x"=x,"y"=y}
	v:add = __vec2_add
	v:sub = __vec2_sub
	v:mul = __vec2_mul
	v:div = __vec2_div
	leave v
}

__vec3_add = fun(c) ? vec3(this.x+c.x,this.y+c.y,this.z+c.z)
__vec3_sub = fun(c) ? vec3(this.x-c.x,this.y-c.y,this.z-c.z)
__vec3_mul = fun(c) ? vec3(this.x*c.x,this.y*c.y,this.z*c.z)
__vec3_div = fun(c) ? vec3(this.x/c.x,this.y/c.y,this.z/c.z)
__vec3_lerp = fun(c,t) ? vec3(lerp(t,this.x,c.x),lerp(t,this.y,c.y),lerp(t,this.z,c.z))

vec3 = fun(x,y,z) ? {
	let v = ({"x"=x,"y"=y,"z"=z})
	v:add = __vec3_add
	v:sub = __vec3_sub
	v:mul = __vec3_mul
	v:div = __vec3_div
	leave v
}


let enum {
	LEFT  = vec3(-1, 0, 0),
	RIGHT = vec3( 1, 0, 0),
	UP    = vec3( 0, 1, 0),
	DOWN  = vec3( 0,-1, 0),
}


// vec2_add = fun(a,b) ? vec2(a.x+b.x,a.y+b.y)
vec3_add = fun(a,b) ? vec3(a.x+b.x,a.y+b.y,a.z+b.z)
vec3_sub = fun(a,b) ? vec3(a.x-b.x,a.y-b.y,a.z-b.z)
vec3_lerp = fun(t,a,b) ? vec3(lerp(t,a.x,b.x),lerp(t,a.y,b.y),lerp(t,a.z,b.z))
/* todo: */
vec3_floor = fun(a,b) ? vec3(ntoi(a.x),ntoi(a.y),ntoi(a.z))

// let enum {
// 	TILESET_ROWLEN =  10,
// 	TILE_SLOTDIMEN =  18,
// 	TILE_DRAWDIMEN = 128,
// }

let enum {
	TILESET_ROWLEN =  11,
	TILE_SLOTDIMEN =  32,
	TILE_DRAWDIMEN = 128,
	ISO_TILE_XSKEW = .50,
	ISO_TILE_YSKEW = .25,
	ISO_TILE_XSCALE = TILE_DRAWDIMEN * ISO_TILE_XSKEW,
	ISO_TILE_YSCALE = TILE_DRAWDIMEN * ISO_TILE_YSKEW,
	ISO_TILE_ZSCALE = TILE_DRAWDIMEN * ISO_TILE_YSKEW,
}

/* all critters are on a singular table,
indexed by position in world */
critters = {}
World = {}


WorldSide = 16
WorldSize = WorldSide*WorldSide*WorldSide
camerax = -256
cameray = 0



// let enum {
// 	GRASS  = 0,
// 	DIRT   = 6,
// 	AIR    = 9,
// 	WATER  = 23,
// 	OAK    = 30,
// 	LEAF   = 40,
// }

let enum {
	AIR    = 1000,
	DIRT   = 0,
	GRASS  = 23,
	FLOWER = 42,
	OAK    = 30,
	LEAF   = 40,
	TRUNK  = 48,
	WATER  = 110,
}


let enum xorshift = fun(x) ? {
	x = x ^ x << 13
	x = x ^ x >> 7
	x = x ^ x << 17
	leave x
}


rndstate = 5282
let enum rnd = fun(x,y) ? {
	rndstate = xorshift(rndstate)
	if rndstate < 0 ? rndstate = -rndstate
	leave x + rndstate % (y - x)
}


let toworldid = fun(x,y,z) ? {
	leave WorldSide*WorldSide*z + WorldSide * y + x
}

let toworldid3 = fun(xyz) ? toworldid(xyz.x,xyz.y,xyz.z)

let gettileid = fun(x,y,z) ? {
	leave World[toworldid(x,y,z)]
}


let settileid = fun(tileid,x,y,z) ? {
	World[toworldid(x,y,z)] = tileid
}

let gettileid3 = fun(xyz) ? gettileid(xyz.x,xyz.y,xyz.z)
let settileid3 = fun(id,xyz) ? settileid(id,xyz.x,xyz.y,xyz.z)

World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
for i in 0..16 ? {
	settileid(GRASS,rnd(0,8),rnd(0,8),0)
	settileid(FLOWER,rnd(0,8),rnd(0,8),1)
}




// let addtree = fun(x,y) ? {
// 	settileid(OAK,x,y,1)
// 	settileid(OAK,x,y,2)
// 	settileid(LEAF,x,y,3)
// 	settileid(LEAF,x,y,4)
// 	settileid(LEAF,x+1,y,3)
// 	settileid(LEAF,x-1,y,3)
// 	settileid(LEAF,x,y+1,3)
// 	settileid(LEAF,x,y-1,3)
// }
// addtree(1,1)


lgi_initWindowed(720,512, "rogue")

textures = {
	"tiles" = lgi_loadtexture("tiles2.png"),
	"stag" = lgi_loadtexture("critter_stag.png"),
	"wolf" = lgi_loadtexture("critter_wolf.png"),
}


/* make it so that we change the default sampler */
for i in 0..textures:length() ? {
	lgi_setsampler(textures:idx(i),"point")
}


unplot = fun (x,y,z) ? {
	let xx = (x + camerax) / ISO_TILE_XSKEW
	let yy = (y + cameray) / ISO_TILE_YSKEW
	let ss = TILE_DRAWDIMEN * 2.
	leave vec3_floor(vec3( (yy + xx) / ss, (yy - xx) / ss, z))
}


raycast = fun (x,y) ? {
	/* todo: figure out the starting tile */
	for z in 0..8 ? {
		let p = unplot(x,y,8-1-z)
		if gettileid3(p) != AIR ? leave p
	}
	leave nil
}


plotline = fun(x0,y0,x1,y1) ? {
	let ix0 = (x0 - y0) * ISO_TILE_XSCALE - camerax
	let iy0 = (x0 + y0) * ISO_TILE_YSCALE - cameray
	let ix1 = (x1 - y1) * ISO_TILE_XSCALE - camerax
	let iy1 = (x1 + y1) * ISO_TILE_YSCALE - cameray
	lgi_drawline(lgi_BLUE,1,ix0,iy0,ix1,iy1)
}


plotgrid = fun() ? {
	for i in 0..8 ? {
		plotline(0,i,8,i)
		plotline(i,0,i,8)
	}
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	plotline(x,y,x+1,y+0)
	plotline(x,y,x+0,y+1)
	plotline(x+1,y+1,x+1,y+0)
	plotline(x+0,y+1,x+1,y+1)
}


plot = fun(x,y,z) ? {
	leave vec2(
	(x - y) * ISO_TILE_XSCALE - camerax,
	(x + y) * ISO_TILE_YSCALE + z*ISO_TILE_ZSCALE - cameray)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset the tiles cuz of the sprite */
	let px = (x - y - 1) * ISO_TILE_XSCALE - camerax
	let py = (x + y - 1) * ISO_TILE_YSCALE + z*ISO_TILE_ZSCALE - cameray
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


// let move = fun(x) ? {
// 	// camerax = camerax + -x.x * 10
// 	// cameray = cameray + -x.y * 10
// 	critterx = critterx + x.x
// 	crittery = crittery + x.y
// }


updatecritterstate = fun(xthis,state) ? {
	if state != xthis.state ? {
		xthis.prevstate = xthis.state
		xthis.state = state
	}
}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


movecritter = fun(xthis,offset) ? {
	// if xthis.ismoving ? leave ()
	let origin = xthis.xyzmov
	__logging(true)
	let target = origin:add(offset)
	__logging(false)
	pf("offset: (",offset,")")
	pf("origin: (",origin,")")
	pf("target: (",target,")")
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	let upper =  target:add(vec3(0,0,1))
	pf("above: (",upper,") = ", gettileid3(upper))
	// pf("above 1: ", gettileid3(vec3_add(target,vec3(0,0,1))))
	if gettileid3(target:add(vec3(0,0,1))) != AIR ? leave false
	// if gettileid3(vec3_add(target,vec3(0,0,1))) != AIR ? leave false
	let critter = getcritter(target)
	if critter != nil ? leave false
	critters[toworldid3(origin)] = nil
	critters[toworldid3(target)] = xthis
	xthis.xyzmov = target
	xthis.ismoving = true
	leave true
}


crittercontroller_player = fun(critter) ? {
	if lgi_testKey('W') ? movecritter(critter,RIGHT)
	if lgi_testKey('D') ? movecritter(critter,DOWN)
	if lgi_testKey('A') ? movecritter(critter,UP)
	if lgi_testKey('S') ? movecritter(critter,LEFT)
}


crittercontroller_dummy = fun(critter) ? {
	if critter.turntimer < .0 ? {
		critter.turntimer = critter.turnclock
		movecritter(critter,vec3(rnd(-1,2),rnd(-1,2),0))
		// if gettileid3(critter.xyz) == GRASS ? {
		// 	updatecritterstate(critter,"grazing")
		// } else {
		// 	updatecritterstate(critter,critter.prevstate)
		// }
	}
	critter.turntimer = critter.turntimer - lgi_deltatime()
}


critterplotter_stag = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(xthis.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y
	let xanim = 32 * ((lgi_time() / .128) % 23)
	// if xthis.state == "grazing" ? {
	// 	xanim = 32 * (21 + (lgi_time() / .512) % 4)
	// }
	let w = 32.
	let h = 41.
	let a = h / w
	let s = 128

	px = px - s*.35
	py = py + s*.05
	// lgi_drawQuad(lgi_WHITE,px,py,s,s*a)
	// xanim,8*41
	lgi_drawtexture(textures.stag,px,py,s,s*a,xanim,41*11,32,41)
}


critterplotter_wolf = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(critter.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y

	let xanim = 64 * ((lgi_time() / .128) % 4)
	let w = 64.
	let h = 64.
	let a = h / w
	let s = 256
	let v = s*a
	px = px - s*.5
	py = py - v*.2
	// lgi_drawQuad(lgi_WHITE,px,py,256,v)
	lgi_drawtexture(textures.wolf,px,py,s,v,xanim,64*12,64,64)
}


newcritter = fun(xyz) ? {
	let xthis = {}
	updatecritterstate(xthis,"idle")
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	xthis.ticked = false
	xthis.turnclock = 2.
	xthis.turntimer = 2.
	xthis.moveclock = .256
	xthis.movetimer = .0
	xthis.ismoving = false
	xthis.xyz = xyz
	xthis.xyzmov = xyz
	xthis.controller = crittercontroller_dummy
	xthis.plotter = critterplotter_stag

	critters[toworldid3(xyz)] = xthis
	leave xthis
}


newwolf = fun(xyz) ? {
	let xthis = newcritter(xyz)
	xthis.controller = crittercontroller_player
	xthis.plotter = critterplotter_wolf
	critters[toworldid3(xthis.xyz)] = xthis
	leave xthis
}


tickcritter = fun(xthis) ? {
	if xthis.ticked ? leave ()
	xthis.ticked = true
	xthis.controller(xthis)
	if xthis.movetimer >= xthis.moveclock ? {
		xthis.ismoving = false
		xthis.movetimer = 0
	}
	if xthis.ismoving ? {
		let movedelta = xthis.movetimer / xthis.moveclock
		xthis.xyz = vec3_lerp(movedelta,xthis.xyz,xthis.xyzmov)
		xthis.movetimer = xthis.movetimer + lgi_deltatime()
	}
}


plotcritter = fun(xthis) ? {
	xthis.ticked = false
	xthis.plotter(xthis)
	// plottileoutline(xthis.xyz)
}


for i in 0..4 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	// newcritter(vec3(rnd(1,4),rnd(1,4),0))
}

let wolf = newwolf(vec3(0,0,0))

forvisibletiles = fun(per) ? {
	for z in 0..12 ? {
		for y in 0..12 ? {
			let iy = 12-1-y
			for x in 0..12 ? {
				let ix = 12-1-x
				per(ix,iy,z)
			}
		}
	}
}


do {
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()
	// if lgi_testKey('W') ? move(UP)
	// if lgi_testKey('D') ? move(RIGHT)
	// if lgi_testKey('A') ? move(LEFT)
	// if lgi_testKey('S') ? move(DOWN)
	lgi_clearBackground();

	forvisibletiles(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})

	forvisibletiles(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
		if z > 0 ? {
			let critter = critters[toworldid(x,y,z-1)]
			if critter != nil ? {
				plotcritter(critter)
			}
		}
	})
	if lgi_isclick(0) ? {
		let hit = raycast(xcursor,ycursor)
		if hit != nil ? {
			plottileoutline(hit)
			settileid3(TRUNK,vec3_add(hit,vec3(0,0,1)))
		}
		// let world = unplot(xcursor,ycursor,1)
		// plottileoutline(world)
		// settileid3(TRUNK,world)
		// plotgrid()
	}

} while lgi_tick()





