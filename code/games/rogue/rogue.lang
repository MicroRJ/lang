__logging(false)

load "code/games/lgi.lang"

if _chdir("code/games/rogue") ? {
	pf("invalid pwd: ", pwd())
	leave false
}

lerp = fun(x,y,z) ? (y + x * (z - y))
unlerp = fun(x,y,z) ? ((x - y) / (z - y))
map = fun(x,y,z,w,v) ? lerp(unlerp(x,y,z),w,v)

vec3__ = {
	add = fun(c) ? vec3(this.x+c.x,this.y+c.y,this.z+c.z),
	sub = fun(c) ? vec3(this.x-c.x,this.y-c.y,this.z-c.z),
	mul = fun(c) ? vec3(this.x*c.x,this.y*c.y,this.z*c.z),
	div = fun(c) ? vec3(this.x/c.x,this.y/c.y,this.z/c.z),
	lerp = fun(c,t) ? vec3(lerp(t,this.x,c.x),lerp(t,this.y,c.y),lerp(t,this.z,c.z)),
	floor = fun() ? vec3(floor(this.x),floor(this.y),floor(this.z))
}

/* todo: instead use new keyword,
new vec3__ {} */
vec3 = fun(x,y,z) ? __of(vec3__,{"x"=x,"y"=y,"z"=z})


let enum {
	LEFT  = vec3(-1, 0, 0),
	RIGHT = vec3( 1, 0, 0),
	UP    = vec3( 0, 1, 0),
	DOWN  = vec3( 0,-1, 0),
}


// let enum {
// 	TILESET_ROWLEN =  10,
// 	TILE_SLOTDIMEN =  18,
// 	TILE_DRAWDIMEN = 128,
// }

let enum {
	TILESET_ROWLEN =  11,
	TILE_SLOTDIMEN =  32,
	TILE_DRAWDIMEN = 128,
	ISO_TILE_XSKEW = .50,
	ISO_TILE_YSKEW = .25,
	ISO_TILE_ZSKEW = .25,
	ISO_TILE_XSCALE = TILE_DRAWDIMEN * ISO_TILE_XSKEW,
	ISO_TILE_YSCALE = TILE_DRAWDIMEN * ISO_TILE_YSKEW,
	ISO_TILE_ZSCALE = TILE_DRAWDIMEN * ISO_TILE_ZSKEW,
}

/* all critters are on a singular table,
indexed by position in world */
critters = {}
World = {}


WorldSide = 16
WorldSize = WorldSide*WorldSide*WorldSide
camerax = 0
cameray = 0



// let enum {
// 	GRASS  = 0,
// 	DIRT   = 6,
// 	AIR    = 9,
// 	WATER  = 23,
// 	OAK    = 30,
// 	LEAF   = 40,
// }

let enum {
	AIR    = 1000,
	DIRT   = 0,
	GRASS  = 23,
	FLOWER = 42,
	OAK    = 30,
	LEAF   = 40,
	TRUNK  = 48,
	WATER  = 110,
}


let enum xorshift = fun(x) ? {
	x = x ^ x << 13
	x = x ^ x >> 7
	x = x ^ x << 17
	leave x
}


rndstate = 5282
let enum rnd = fun(x,y) ? {
	rndstate = xorshift(rndstate)
	if rndstate < 0 ? rndstate = -rndstate
	leave x + rndstate % (y - x)
}


let toworldid = fun(x,y,z) ? {
	leave WorldSide*WorldSide*z + WorldSide * y + x
}

let toworldid3 = fun(xyz) ? toworldid(xyz.x,xyz.y,xyz.z)

let gettileid = fun(x,y,z) ? {
	leave World[toworldid(x,y,z)]
}


let settileid = fun(tileid,x,y,z) ? {
	World[toworldid(x,y,z)] = tileid
}

let gettileid3 = fun(xyz) ? gettileid(xyz.x,xyz.y,xyz.z)
let settileid3 = fun(id,xyz) ? settileid(id,xyz.x,xyz.y,xyz.z)

World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
for i in 0..WorldSide*WorldSide/2 ? {
	settileid(GRASS,rnd(0,16),rnd(0,16),0)
	settileid(FLOWER,rnd(0,16),rnd(0,16),1)
}

settileid(GRASS,0,0,1)
settileid(GRASS,0,0,2)
settileid(GRASS,0,0,3)
settileid(GRASS,0,0,4)





// let addtree = fun(x,y) ? {
// 	settileid(OAK,x,y,1)
// 	settileid(OAK,x,y,2)
// 	settileid(LEAF,x,y,3)
// 	settileid(LEAF,x,y,4)
// 	settileid(LEAF,x+1,y,3)
// 	settileid(LEAF,x-1,y,3)
// 	settileid(LEAF,x,y+1,3)
// 	settileid(LEAF,x,y-1,3)
// }
// addtree(1,1)


lgi_initWindowed(720,512, "rogue")

textures = {
	"tiles" = lgi_loadtexture("tiles2.png"),
	"stag" = lgi_loadtexture("critter_stag.png"),
	"wolf" = lgi_loadtexture("critter_wolf.png"),
}


/* make it so that we change the default sampler */
for i in 0..textures:length() ? {
	lgi_setsampler(textures:idx(i),"point")
}


unplot = fun (x,y,z) ? {
	let xx = (x - lgi_getSizeX() * .5) / ISO_TILE_XSKEW
	let yy = (y - lgi_getSizeY() * .5) / ISO_TILE_YSKEW
	let ss = TILE_DRAWDIMEN * 2.
	let wx = (yy + xx) / ss + camerax
	let wy = (yy - xx) / ss + cameray
	let wz = z // ((y - (wx + wy) * ISO_TILE_YSKEW) / ISO_TILE_ZSKEW) / ss
	leave vec3(wx,wy,wz):floor()
}


raycast = fun (x,y) ? {
	/* todo: figure out the starting tile */
	for z in 0..8 ? {
		let p = unplot(x,y,8-1-z)
		if gettileid3(p) != AIR ? leave p
	}
	leave nil
}


plot = fun(x,y,z) ? {
	let xx = x - camerax
	let yy = y - cameray
	let xxx = (xx - yy) * ISO_TILE_XSCALE
	let yyy = (xx + yy) * ISO_TILE_YSCALE + z*ISO_TILE_ZSCALE

	let wx = lgi_getSizeX()*.5
	let wy = lgi_getSizeY()*.5
	leave vec3(xxx+wx,yyy+wy, 0)
}


plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)

plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	// let ix0 = (x0 - y0 - camerax) * ISO_TILE_XSCALE
	// let iy0 = (x0 + y0 - cameray) * ISO_TILE_YSCALE
	// let ix1 = (x1 - y1 - camerax) * ISO_TILE_XSCALE
	// let iy1 = (x1 + y1 - cameray) * ISO_TILE_YSCALE
	// lgi_drawline(lgi_BLUE,1,ix0,iy0,ix1,iy1)
	lgi_drawline(lgi_BLUE,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotgrid = fun() ? {
	for i in 0..8 ? {
		plotline(0,i,8,i)
		plotline(i,0,i,8)
	}
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	plotline(x,y,x+1,y+0)
	plotline(x,y,x+0,y+1)
	plotline(x+1,y+1,x+1,y+0)
	plotline(x+0,y+1,x+1,y+1)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset the tiles cuz of the sprite */
	let p = plot(x-1,y,z)
	let px = p.x
	let py = p.y
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


// let move = fun(x) ? {
// 	// camerax = camerax + -x.x * 10
// 	// cameray = cameray + -x.y * 10
// 	critterx = critterx + x.x
// 	crittery = crittery + x.y
// }


updatecritterstate = fun(xthis,state) ? {
	if state != xthis.state ? {
		xthis.prevstate = xthis.state
		xthis.state = state
	}
}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


movecritter = fun(xthis,offset) ? {
	let origin = xthis.xyzmov
	let target = origin:add(offset)
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	let id = gettileid3(target:add(vec3(0,0,1)))
	if id != AIR && id != FLOWER ? {
		leave false
	}
	let critter = getcritter(target)
	if critter != nil ? leave false
	critters[toworldid3(origin)] = nil
	critters[toworldid3(target)] = xthis
	xthis.xyzmov = target
	xthis.ismoving = true
	leave true
}


crittercontroller_player = fun(critter) ? {
	if lgi_testKey('W') ? movecritter(critter,RIGHT)
	if lgi_testKey('D') ? movecritter(critter,DOWN)
	if lgi_testKey('A') ? movecritter(critter,UP)
	if lgi_testKey('S') ? movecritter(critter,LEFT)
}


crittercontroller_dummy = fun(critter) ? {
	if critter.turntimer < .0 ? {
		critter.turntimer = critter.turnclock
		movecritter(critter,vec3(rnd(-1,2),rnd(-1,2),0))
		// if gettileid3(critter.xyz) == GRASS ? {
		// 	updatecritterstate(critter,"grazing")
		// } else {
		// 	updatecritterstate(critter,critter.prevstate)
		// }
	}
	critter.turntimer = critter.turntimer - lgi_deltatime()
}


critterplotter_stag = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(xthis.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y
	let xanim = 32 * ((lgi_time() / .128) % 23)
	// if xthis.state == "grazing" ? {
	// 	xanim = 32 * (21 + (lgi_time() / .512) % 4)
	// }
	let w = 32.
	let h = 41.
	let a = h / w
	let s = 128

	px = px - s*.35
	py = py + s*.05
	// lgi_drawQuad(lgi_WHITE,px,py,s,s*a)
	// xanim,8*41
	lgi_drawtexture(textures.stag,px,py,s,s*a,xanim,41*11,32,41)
}


critterplotter_wolf = fun(xthis) ? {
	let xyz = xthis.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like xthis */
	// let px,py = plot(critter.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y

	let xanim = 64 * ((lgi_time() / .128) % 4)
	let w = 64.
	let h = 64.
	let a = h / w
	let s = 256
	let v = s*a
	px = px - s*.5
	py = py - v*.2
	// lgi_drawQuad(lgi_WHITE,px,py,256,v)
	lgi_drawtexture(textures.wolf,px,py,s,v,xanim,64*12,64,64)
}


newcritter = fun(xyz) ? {
	let xthis = {}
	updatecritterstate(xthis,"idle")
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	xthis.ticked = false
	xthis.turnclock = 2.
	xthis.turntimer = 2.
	xthis.moveclock = .256
	xthis.movetimer = .0
	xthis.ismoving = false
	xthis.xyz = xyz
	xthis.xyzmov = xyz
	xthis.controller = crittercontroller_dummy
	xthis.plotter = critterplotter_wolf

	critters[toworldid3(xyz)] = xthis
	leave xthis
}


newstag = fun(xyz) ? {
	let xthis = newcritter(xyz)
	xthis.controller = crittercontroller_player
	xthis.plotter = critterplotter_stag
	leave xthis
}


tickcritter = fun(xthis) ? {
	if xthis.ticked ? leave ()
	xthis.ticked = true
	xthis.controller(xthis)
	if xthis.movetimer >= xthis.moveclock ? {
		xthis.ismoving = false
		xthis.movetimer = 0
	}
	if xthis.ismoving ? {
		let movedelta = xthis.movetimer / xthis.moveclock
		xthis.xyz = xthis.xyz:lerp(xthis.xyzmov,movedelta)
		xthis.movetimer = xthis.movetimer + lgi_deltatime()
	}
}


plotcritter = fun(xthis) ? {
	xthis.ticked = false
	xthis.plotter(xthis)
	// plottileoutline(xthis.xyz)
}


for i in 0..8 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	newcritter(vec3(rnd(1,12),rnd(1,12),0))
}

wolf = newstag(vec3(0,2,0))

forvisibletiles = fun(per) ? {
	for y in 0..12 ? {
		let iy = 12-1-y
		for x in 0..12 ? {
			let ix = 12-1-x
			for z in 0..12 ? {
				per(ix,iy,z)
			}
		}
	}
}


/* todo: we can do lighting trick by
rendering tiles less times */
do {
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()

	// pf(plot3(wolf.xyz))
	// let wolfonscreen = plot3(wolf.xyz)
	// pf(wolfonscreen)
	camerax = wolf.xyz.x
	cameray = wolf.xyz.y
	// pf(camerax, ", ", cameray)
	// if lgi_testKey('W') ? move(UP)
	// if lgi_testKey('D') ? move(RIGHT)
	// if lgi_testKey('A') ? move(LEFT)
	// if lgi_testKey('S') ? move(DOWN)

	lgi_clearBackground();

	forvisibletiles(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})

	forvisibletiles(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
		if z > 0 ? {
			let critter = critters[toworldid(x,y,z-1)]
			if critter != nil ? {
				plotcritter(critter)
			}
		}
	})

	let world = unplot(xcursor,ycursor,0)
	plottileoutline(world)

	if lgi_isbuttondown(0) ? {
		// let hit = raycast(xcursor,ycursor)
		// if hit != nil ? {
		// 	plottileoutline(hit)
		// 	settileid3(TRUNK,hit:add(vec3(0,0,1)))
		// }
		// settileid3(TRUNK,world)
	} elif lgi_isbuttondown(1) ? {
		plotgrid()
	}
} while lgi_tick()





