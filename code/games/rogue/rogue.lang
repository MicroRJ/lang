__logging(false)

log ?= pf

load "code/games/lgi.elf"

if _chdir("code/games/rogue") ? {
	pf("invalid pwd: ", pwd())
	leave false
}
/* this is done at runtime, which
is not the greatest thing */
load "vec.elf"
load "rnd.lang"
load "font.lang"
load "tiles.lang"
load "world.elf"
load "critter.elf"
load "wolf.elf"
load "stag.elf"

issolid = fun(tile) ? {
	let id = gettileid3(tile)
	leave id != WATER && id != AIR && id != FLOWER
}

LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)
/* these are world directions, named as what
they look to the user */
NW = vec3(0,1,0)
NE = vec3(1,0,0)
SW = vec3(-1,0,0)
SE = vec3(0,-1,0)

TILE_DRAWDIMEN = 128
ISO_XSKEW = .50
ISO_YSKEW = .25
ISO_XSCALE = TILE_DRAWDIMEN * ISO_XSKEW
ISO_YSCALE = TILE_DRAWDIMEN * ISO_YSKEW
/* all critters are on a singular table,
indexed by position in world */

camera = {
	xyz = vec3(0,0,0)
}


lgi_initWindowed(720,512, "rogue")

loadassets = fun() ? {
	let time_ = clocktime()
	finally pf("loaded assets, took => ", timediffs(time_))

	elf.pf("loading assets... ")
	textures = {
		tiles = lgi_loadtexture("assets/tiles2.png"),
		stag = lgi_loadtexture("assets/critter_stag.png"),
		wolf = lgi_loadtexture("assets/critter_wolf.png"),
	}
	/* make it so that we can change the default sampler */
	for i in 0..textures:length() ? {
		lgi_setsampler(textures:idx(i),"point")
	}
	loadfont()
}
loadassets()


pf("generating world...")
World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
// for i in 0..WorldSide*WorldSide/2 ? {
// 	settileid(GRASS,rnd(0,16),rnd(0,16),0)
// 	settileid(FLOWER,rnd(0,16),rnd(0,16),1)
// }

settileid(GRASS,6,6,1)
settileid(GRASS,7,6,2)
settileid(GRASS,8,6,3)
settileid(GRASS,9,6,4)
settileid(GRASS,9,7,4)
settileid(GRASS,9,8,4)
settileid(GRASS,9,9,4)

settileid(GRASS,0,0,1)
settileid(GRASS,0,0,2)
settileid(GRASS,0,0,3)
settileid(GRASS,0,0,4)
settileid(GRASS,0,0,5)
settileid(GRASS,0,0,6)
settileid(GRASS,0,0,7)
settileid(GRASS,0,1,7)
settileid(GRASS,0,2,7)
settileid(GRASS,0,3,7)



plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)
plot = fun(x,y,z) ? {
	let xx = x - camera.xyz.x
	let yy = y - camera.xyz.y
	let zz = z - camera.xyz.z
	let xxx = (xx - yy) * ISO_XSCALE
	let yyy = (xx + yy + zz) * ISO_YSCALE
	let wx = xxx + lgi_getSizeX()*.5
	let wy = yyy + lgi_getSizeY()*.5
	leave vec3(wx,wy,0)
}


unplot = fun (x,y,wz) ? {
	let cxyz = camera.xyz
	let cx = cxyz.x
	let cy = cxyz.y
	let cz = cxyz.z
	let xx = (x-lgi_getSizeX()*.5) / (ISO_XSCALE*2)
	let yy = (y-lgi_getSizeY()*.5) / (ISO_YSCALE*2)
	let yyy = yy + (cz-wz)*.5
	let wx = floor(yyy+xx+cx)
	let wy = floor(yyy-xx+cy)
	leave vec3(wx,wy,wz)
}


plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	lgi_drawline(lgi_BLUE,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotline3 = fun(color,x0,y0,z0,x1,y1,z1) ? {
	let p0 = plot(x0,y0,z0)
	let p1 = plot(x1,y1,z1)
	lgi_drawline(color,1,p0.x,p0.y,p1.x,p1.y)
}


plotgrid = fun() ? {
	let color = lgi_BLUE
	color.a = .5
	for z in 0..8 ? {
		plotline3(color,0,0,z,8,0,z)
		plotline3(color,0,0,z,0,8,z)
	}
	for z in 0..1 ? {
		for i in 0..8 ? {
			plotline3(color,0,i,z,8,i,z)
			plotline3(color,i,0,z,i,8,z)
		}
	}
	// color = lgi_RED
	// color.a = .1
	// for y in 0..8 ? {
	// 	for x in 0..8 ? {
	// 		plotline3(color,x,y,0,x,y,8)
	// 	}
	// }
}


plotdebugfacex = fun(xyz,w,h) ? {
	let x = xyz.x, y = xyz.y, z = xyz.z
	plotline3(lgi_BLUE,x,y,z,x,y+w,z)
	plotline3(lgi_BLUE,x,y,z,x,y,z+h)
	plotline3(lgi_BLUE,x,y+w,z+h,x,y,z+h)
	plotline3(lgi_BLUE,x,y+w,z,x,y+w,z+h)
}


plotdebugfacey = fun(xyz,w,h) ? {
	let x = xyz.x, y = xyz.y, z = xyz.z
	plotline3(lgi_BLUE,x,y,z,x+w,y,z)
	plotline3(lgi_BLUE,x,y,z,x,y,z+h)
	plotline3(lgi_BLUE,x+w,y,z+h,x,y,z+h)
	plotline3(lgi_BLUE,x+w,y,z,x+w,y,z+h)
}


plotdebugcube = fun(xyz,sx,sy,sz) ? {
	plotdebugfacex(xyz,sx,sz)
	plotdebugfacey(xyz,sx,sz)
	plotdebugfacex(xyz:add(vec3(sx,0,0)),sx,sz)
	plotdebugfacey(xyz:add(vec3(0,sy,0)),sx,sz)
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	plotline3(lgi_BLUE,x+0,y+0,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+0,z,x+0,y+1,z)
	plotline3(lgi_BLUE,x+1,y+1,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+1,z,x+1,y+1,z)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset x by -1 just so that the
	sprite aligns visually with the grid */
	let p = plot(x-1,y,z)
	let px = p.x
	let py = p.y
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


for i in 0..4 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	// newwolf(vec3(rnd(1,12),rnd(1,12),0))
}

wolf = newstag(vec3(0,2,0))

fortilesinplotorder = fun(per) ? {
	let numvis = 12
	let camx = camera.xyz.x
	let camy = camera.xyz.y
	let y0 = 0 // camera.xyz.y
	let y1 = numvis // camera.xyz.y+numvis
	for y in y0..y1 ? {
		let iy = numvis-1-y
		for x in 0..numvis ? {
			let ix = numvis-1-x
			for z in 0..numvis ? {
				per(ix,iy,z)
			}
		}
	}
}

plotgame = fun() ? {
	fortilesinplotorder(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})
	fortilesinplotorder(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
		if z > 0 ? {
			let critter = critters[toworldid(x,y,z-1)]
			if critter != nil ? {
				plotcritter(critter)
			}
		}
	})
}

raycast = fun(x,y) ? {
	/* if I was smart I could figure out how to
	make this more efficient */
	/* todo: break statements */
	let looping = true
	let level = 0
	let hit = nil
	while looping == true ? {
		let world = unplot(x,y,level)
		if world.x < 0 ? looping = false
		if world.y < 0 ? looping = false
		if level > 128 ? __debugbreak()
		if looping == true ? {
			level = level + 1
			if issolid(world) ? hit = world
		}
	}
	leave hit
}


showgrid = false
trackplayer = true
editormode = false
/* todo: we can do lighting trick by
rendering tiles less times */

input = nil
timelastchar = 0
fadeouttimer = 2.
pickedtileid = TRUNK
do {
	let width = lgi_getSizeX()
	let height = lgi_getSizeY()
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()

	if lgi_testKey('1') ? editormode = editormode == false

	if editormode == false ? {
		if lgi_testKey('G') ? showgrid = showgrid == false
		if lgi_testKey('T') ? trackplayer = trackplayer == false
	}
	if trackplayer ? camera.xyz = wolf.xyz:clone()

	let hit = raycast(xcursor,ycursor)

	if editormode == true ? {
		for i in 'A'..'Z' ? {
			if lgi_testKey(i) ? {
				timelastchar = clocktime()
				input ?= ""
				input = input:append(i)
			}
		}
		if hit != nil ? {
			if lgi_isclick(1) ? {
				if hit != nil ? settileid3(AIR,hit)
			} else
			if lgi_isclick(0) ? {
				if hit != nil ? settileid3(pickedtileid,hit:add(vec3(0,0,1)))
			}
		}
	}

	lgi_clearBackground();
	plotgame()

	if showgrid ? plotgrid()
	if showgrid ? plotdebugcube(vec3(0,0,0),12,12,12)
	if hit != nil ? plotdebugcube(hit,1,1,1)

	if editormode == true ? {
		if input != nil ? {
			let time = timediffs(timelastchar)
			if time > fadeouttimer ? {
				input = nil
			} else {
				let tileid = TILENAMES[input]
				if tileid != nil ? {
					pickedtileid = tileid
					lgi_drawtexture(textures.tiles,0,0
					,TILE_DRAWDIMEN,TILE_DRAWDIMEN
					,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
					,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
					,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
				}
				let color = lgi_WHITE
				color.a = 1. - time/fadeouttimer
				plottext(0,0,input,64,color)
			}
		}
	}
	// let temp = ftemp()
	// fpf(temp,"fps: ",1./lgi_deltatime(), ", num: ", World:length(), ", ", critters:length())
	// let fps = freadall(temp)
	// fclose(temp)
	// plottext(0,0,fps)
} while lgi_tick()





