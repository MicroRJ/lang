
updatecritterstate = fun(xthis,state) ? {
	if state != xthis.state ? {
		xthis.prevstate = xthis.state
		xthis.state = state
	}
}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


orientcritter = fun(xthis,dir) ? {
	let facing = xthis.facing
	if facing:eq(dir) == false ? {
		xthis.facing = dir:clone()
		leave (false)
	} else leave (true)
}


movecritter = fun(xthis,move,dir) ? {
	if xthis.kind == "dummy" ? {
		log("warning: dummy critters cannot be moved")
		leave false
	}
	if xthis.transing ? leave false
	let facing = xthis.facing
	if facing:eq(dir) == false ? {
		xthis.facing = dir:clone()
		leave (false)
	}
	if move == 0 ? leave (true)
	let origin = xthis.transtiletarget
	let target = origin:add(dir:mul1(move))
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	let height = xthis.height
	/* 0 floor, 1 jumpable, include the tile past
	the height, because tiles are 1 in depth */
	for z in 2..height+1 ? {
		if issolid(target:add(vec3(0,0,z))) ? {
			leave (false)
		}
	}
	if issolid(target:add(vec3(0,0,1))) ? {
		target = target:add(vec3(0,0,1))
	/* check if we're going to fall */
	} else iff issolid(target) ? {
		/* if the fall is too steep bail */
		iff issolid(target:add(vec3(0,0,-1))) ? {
			leave (false)
		}
		target = target:add(vec3(0,0,-1))
	}
	let critter = getcritter(target)
	if critter != nil ? {
		if critter.kind == "dummy" ? {
			if critter.proxy != xthis ? {
				leave (false)
			}
		} else leave (false)
	}

	let facing = xthis.facing
	/* this is to make the game more appealing
	visually, it has to do with rendering quirks */
	if facing:eq(NW) || facing:eq(NE) ? {
		/* reserve the target tile so that
		no other entities can occupy it,
		then swap after the move is done,
		this to avoid rendering the tile
		we're currently over above us,
		which is not really that big a
		problem it just makes the game
		seem as if it is artifact'ing a bit  */
	  	let dummy = newcritter("dummy",target)
	  	dummy.proxy = target
  	} else {
  		/* here just swap immediatly so that
  		way render on top of the tile we're
  		going to move to, when the move is done
  		we swap again with ourselves, so no
  		harm done */
		critters[toworldid3(origin)] = nil
		critters[toworldid3(target)] = xthis
  	}
	xthis.transtileorigin = origin
	xthis.transtiletarget = target
	xthis.transing = true

	/* todo: rename this to systime() */
	xthis.timemoved = clocktime()
	leave true
}


crittercontroller_player = fun(critter) ? {
	let move = lgi_isshiftdown() == false
	if lgi_iskeydown('W') ? movecritter(critter,true,RIGHT)
	if lgi_iskeydown('D') ? movecritter(critter,true,DOWN)
	if lgi_iskeydown('A') ? movecritter(critter,true,UP)
	if lgi_iskeydown('S') ? movecritter(critter,true,LEFT)
	if lgi_iskeydown(' ') ? {
		movecritter(critter,3,critter.facing)
	}
}



critterplotter_dummy = fun(critter) ? ()
crittercontroller_dummy = fun(critter) ? ()

newcritter = fun(kind,xyz) ? {
	kind ?= "dummy"
	let xthis = {}
	updatecritterstate(xthis,"idle")
	xthis.kind = kind
	xthis.xyz = xyz
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	xthis.ticked = false
	xthis.turnclock = 2.
	xthis.turntimer = 2.
	xthis.timemoved = 0
	xthis.moveclock = .256
	xthis.transtileorigin = vec3()
	xthis.transtiletarget = xyz
	xthis.transing = false
	xthis.height = 3
	xthis.animtimer = 0.
	xthis.animlabel = "idle"
	xthis.facing = NW
	xthis.controller = crittercontroller_dummy
	xthis.plotter = critterplotter_dummy
	let already = critters[toworldid3(xyz)]
	if already != nil && already != "dummy" ? {
		pf("error, critter already here")
	} else critters[toworldid3(xyz)] = xthis
	leave xthis
}



tickcritter = fun(xthis) ? {
	if xthis.kind == "dummy" ? leave ()
	xthis.ticked = xthis.ticked + 1
	// if xthis.ticked > 1 ? pf("ticked: ", xthis.ticked)
	if xthis.ticked - 1 != 0 ? leave ()
	xthis.ticked = true
	xthis.controller(xthis)
	let diffs = timediffs(xthis.timemoved)
	if xthis.transing ? {
		if diffs < xthis.moveclock ? {
			let movedelta = diffs / xthis.moveclock
			xthis.xyz = xthis.transtileorigin:lerp(xthis.transtiletarget,movedelta)
		} else {
			xthis.transing = false
			let origin = toworldid3(xthis.transtileorigin)
			if critters[origin] != nil ? {
				if critters[origin] == xthis ? {
					critters[origin] = nil
				} elif critters[origin].kind == "dummy" ? {
					if critters[origin].proxy == xthis ? {
						critters[origin] = nil
					}
				}
			}
			critters[toworldid3(xthis.transtiletarget)] = xthis
		}
	}
}


plotcritter = fun(xthis) ? {
	xthis.ticked = false
	xthis.plotter(xthis)
	if showgrid ? plotdebugcube(xthis.xyz,1,1,xthis.height)
}

