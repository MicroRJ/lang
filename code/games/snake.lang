__logging(false)
load "code/games/lgi.lang"

let enum {
	FLOOR = 0,
	APPLE = 1,
	SNAKE = 2
}


let enum int2 = fun(x,y) ? ({"x"=x,"y"=y})
let enum int2_add = fun(x,y) ? int2(x.x+y.x,x.y+y.y)


let enum {
	LEFT  = int2(-1, 0),
	RIGHT = int2( 1, 0),
	UP    = int2( 0, 1),
	DOWN  = int2( 0,-1),
}



let enum xorshift = fun(x) ? {
	x = x ^ x << 13
	x = x ^ x >> 7
	x = x ^ x << 17
	leave x
}


rndstate = 5282
let enum rnd = fun(x,y) ? {
	rndstate = xorshift(rndstate)
	if rndstate < 0 ? rndstate = -rndstate
	leave x + rndstate % (y - x)
}


let enum {
	SIDELEN = 16,
	CELLPX  = 32,
}

let grid = {}
let gsize = SIDELEN*SIDELEN
grid[0..gsize] = FLOOR



let redraw = fun () ? {
	// let _time = clocktime()
	// finally pf(" => took: ", timediffs(_time))
	for y in 0..SIDELEN  ? {
		for x in 0..SIDELEN ? {
			let i = y * SIDELEN + x
			let cell = grid[i]

			let color = lgi_BLACK
			if cell == APPLE ? {
				color = lgi_GREEN
			} elif cell == SNAKE ? {
				color = lgi_RED
			} then {
				let box_x = x * CELLPX + x * 2
				let box_y = y * CELLPX + y * 2
				lgi_drawQuad(color,box_x,box_y,CELLPX,CELLPX)
			}
		}
	}
}


let addapple = fun () ? {
	papl = 0
	iapl = SNAKE
	while iapl != FLOOR ? {
		papl = rnd(0,gsize)
		iapl = grid[papl]
	}
	pf("added apple: ",papl)
	grid[papl] = APPLE
}


let movesnake = fun (snake, dir) ? {
	let length = snake.length
	let body = snake.body
	let n = int2_add(body[0],dir)


	if (n.x < 0 || n.y < 0) ? {

	} elif SIDELEN <= n.x ? {

	} elif SIDELEN <= n.y ? {

	} then {
		snake.collided = true
		leave
	}


			// save the tail in case we eat apple, when we shift the snake forwards we loose the tail so we
			// need to repopulate it to grow, we also use this for clearing the grid in case we did not eat an apple,
			// in which case there will be no snake part present in the tail slot
	let t = body[length-1]

	for i in 1..length ? {
		body[length-i] = body[length-i-1]
	}
	body[0] = n

			// store the previous head value to check for collisions, don't generate apple
			// yet to avoid overwriting the apple with a snake part
	let v = grid[SIDELEN * n.y + n.x]

			// if we ate an apple simply restore the tail at one past the previous tail position
	if v == APPLE ? {
		body[length] = t
		length = length + 1
	} else {
					// if we did not grow then clear the old tail, this will visually glitch the snake
					// if the last tail position overlaps any part of the snake, which will consequently
					// get cleared.
					// The point of the game is for that not to happen, so it doesn't really matter however,
					// to help a bit prevent this.
					// We do redraw the new head and tail only after we've cleared, so that could help
					// if we only overlap the head or tail.
		grid[SIDELEN * t.y + t.x] = FLOOR
	}

				// redraw the head now that it moved
	grid[SIDELEN * n.y + n.x] = SNAKE

				// redraw the tail now that it moved
	let p = body[length-1]
	grid[SIDELEN * p.y + p.x] = SNAKE


	if v == APPLE ? {
		addapple()
	}

	snake.heading = dir
	snake.length = length
}


let addsnake = fun (pos,length,heading) ? {
	let body = {}

	let snake = {}
	snake.length = length
	snake.body = body
	snake.heading = heading
	snake.collided = false

	for i in 0..length ? {
		let id = SIDELEN * pos.y + pos.x
		pf(SIDELEN,", ",pos,", ",pos.y,", ",pos.x,", ",id)
		grid[id] = SNAKE

		body[length-1 - i] = int2(pos.x,pos.y)
		pos.x = pos.x + heading.x
		pos.y = pos.y + heading.y
	}
	leave snake
}


// grid[0..gsize] = APPLE
let snake = addsnake(int2(2,2),4,UP)
addapple()
// pf(grid)

let time = 0
let lastturntime = 0.
let TURN = .128
lgi_initWindowed((CELLPX+3)*SIDELEN,(CELLPX+3)*SIDELEN, "snake")
do {
	lgi_clearBackground();
	redraw()
	let heading = snake.heading
	if lgi_testKey('W') ? {
		heading = UP
	} elif lgi_testKey('D') ? {
		heading = RIGHT
	} elif lgi_testKey('A') ? {
		heading = LEFT
	} elif lgi_testKey('S') ? {
		heading = DOWN
	} then {
		snake.heading = heading
		/* what should actually happen here
		is that we draw the snake in the turn
		direction but don't update the turn
		timer yet */
		// if snake.heading != heading  ? {
		// 	snake.heading = heading
		// 	time = TURN
		// }
	}
	if TURN <= time ? {
		time = 0
		movesnake(snake,snake.heading)
	}
	time = time + lgi_deltatime()
} while lgi_tick()
