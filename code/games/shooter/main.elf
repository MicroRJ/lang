

log ?= pf
load "code/games/lgi.elf"
if _chdir("code/games/shooter") ? {
	pf("invalid pwd: ", pwd())
	leave false
}
load "vec.elf"
load "rnd.lang"


LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)
/* these are world directions, named as what
they look to the user */
NW = vec3(0,1,0)
NE = vec3(1,0,0)
SW = vec3(-1,0,0)
SE = vec3(0,-1,0)

camera = {
	"targetxyz" = vec3(0,0,0),
	"xyz" = vec3(0,0,0)
}


lgi_initWindowed(720,512, "rogue")

loadassets = fun() ? {
	let time_ = clocktime()
	finally pf("loaded assets, took => ", timediffs(time_))
	pf("loading assets... ")
	textures = {
		"player" = lgi_loadtexture("assets/Atlas.png"),
		"background" = lgi_loadtexture("assets/background.png"),
	}
	for i in 0..textures:length() ? {
		lgi_setsampler(textures:idx(i),"point")
	}
}
loadassets()


plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)
plot = fun(x,y,z) ? {
	let xx = iton(x - camera.xyz.x)
	let yy = iton(y - camera.xyz.y)
	let zz = iton(z - camera.xyz.z)
	if zz == 0. ? zz = 1.
	let wx = (xx / zz) + lgi_getSizeX()*.5
	let wy = (yy / zz) + lgi_getSizeY()*.5
	leave vec3(wx,wy,0)
}


unplot = fun (xyz) ? {
	let cxyz = camera.xyz
	let cx = cxyz.x
	let cy = cxyz.y
	let cz = cxyz.z
	let wx = (xyz.x-lgi_getSizeX()*.5)// * (xyz.z + cz)
	let wy = (xyz.y-lgi_getSizeY()*.5)// * (xyz.z + cz)
	leave vec3(wx,wy,wz)
}


plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	lgi_drawline(lgi_YELLOW,1,xy0.x,xy0.y,xy1.x,xy1.y)
}


plotline3 = fun(color,x0,y0,z0,x1,y1,z1) ? {
	let p0 = plot(x0,y0,z0)
	let p1 = plot(x1,y1,z1)
	lgi_drawline(color,1,p0.x,p0.y,p1.x,p1.y)
}


plotgrid = fun() ? {
	let color = lgi_WHITE:a(.5)
	// let width = lgi_getSizeX()
	// let height = lgi_getSizeY()
	// let ngridy = height / 32
	// let xoffset = camera.xyz.x
	// let yoffset = camera.xyz.y
	// for i in ngridy+1 ? {
	// 	let x = - xoffset;
	// 	let y = - (ntoi(yoffset / 32) * 32) + i * 32;
	// 	// drawline(x,y,width+x,y,1,color);
	// 	lgi_drawline(color,1,x,y,width+x,y)
	// }
		// int ngridx = lgi.Window.size_x / 32;
		// for (int i=0; i<ngridx+1; i+=1) {
		// 	int y = - yoffset;
		// 	int x = - ((int)(xoffset / 32) * 32) + i * 32;
		// 	drawline(x,y,x,lgi.Window.size_y+y,1,color);
		// }
	// for z in 0..8 ? {
	// 	plotline3(color,0,0,z,8,0,z)
	// 	plotline3(color,0,0,z,0,8,z)
	// }
	// for z in 0..1 ? {
	// 	for i in 0..8 ? {
	// 		plotline3(color,0,i,z,8,i,z)
	// 		plotline3(color,i,0,z,i,8,z)
	// 	}
	// }
	// color = lgi_RED
	// color.a = .1
	// for y in 0..8 ? {
	// 	for x in 0..8 ? {
	// 		plotline3(color,x,y,0,x,y,8)
	// 	}
	// }
}

plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	plotline3(lgi_BLUE,x+0,y+0,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+0,z,x+0,y+1,z)
	plotline3(lgi_BLUE,x+1,y+1,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+1,z,x+1,y+1,z)
}
rotbyangle = fun(point,angle) ? {
	leave vec3(
	point.x*cos(angle) - point.y*sin(angle),
	point.y*cos(angle) - point.x*sin(angle), 0.)
}
transform = fun(x,y,p) ? {
	leave vec3(p.x * x.x + p.y * x.y,
	           p.x * y.x + p.y * y.y,0.)
}
canvas = {
	"xyz" = vec3(0,0,0),
	"ybasis" = UP,
	"xbasis" = RIGHT,
	"color" = lgi_WHITE,
	"u0" = 0,
	"v0" = 0,
	"u1" = 1,
	"v1" = 1,
}
lgi_vertex2d = fun(x,y,u,v) ? {
	let xyz = transform(canvas.ybasis,canvas.xbasis,vec2(x,y))
	let p = plot3(canvas.xyz:add(xyz))
	lgi_attrxyuv(p.x,p.y,u,v)
	lgi_pushvertex()
}
fxsettex = fun(tex,u0,v0,u1,v1) ? {
	canvas.texture = tex
	let width = lgi_gettexturewidth(tex)
	let height = lgi_gettextureheight(tex)
	canvas.u0 = iton(u0) / width
	canvas.v0 = iton(v0) / height
	canvas.u1 = iton(u1) / width
	canvas.v1 = iton(v1) / height
}
fxaddquad = fun(x0,y0,x1,y1) ? {
	let texture = canvas.texture
	let u0 = canvas.u0
	let v0 = canvas.v0
	let u1 = canvas.u1
	let v1 = canvas.v1
	if texture != nil ? {
		lgi_bindtexture(texture)
	} else lgi_binddeftex()

	lgi_beginvertices(6,4)
	let color = canvas.color
	lgi_attrrgba(color.r,color.g,color.b,color.a)
	lgi_addnidx(0,1,2, 0,2,3)
	lgi_vertex2d(x0,y0,u0,v1)
	lgi_vertex2d(x0,y1,u0,v0)
	lgi_vertex2d(x1,y1,u1,v0)
	lgi_vertex2d(x1,y0,u1,v1)
	lgi_closevertices()
}
Bullets = {}
fire = fun(entity) ? {
	let firerate = entity.firerate
	let lastfire = entity.lastfire
	if timediffs(lastfire) > (1./(firerate/60.)) ? {
		entity.lastfire = clocktime()
		Bullets[Bullets:length()] = ({
			"from" = entity,
			"pos" = entity.xyz,
			"dir" = entity.facing
		})
	}
}
player = {
	"xyz" = vec3(0,0,1),
	"facing" = UP,
	"firing" = false,
	/* in rps, rounds per minute */
	"firerate" = 500,
	"lastfire" = 0.,
	"muscleflashduration" = .032,
}
Entities = {player}
for i in 1..2 ? {
	Entities[i] = {
		"xyz" = vec3(rnd(-128,128),rnd(-128,128),1),
		"facing" = UP,
		"targetfacing" = UP,
		"firing" = false,
		/* in rpm, rounds per minute */
		"firerate" = 50,
		"lastfire" = 0.,
		/* rps, rotations per second */
		"turnrate" = 1.,
		"muscleflashduration" = .032,
	}
}
plotentity = fun(entity) ? {
	let firerate = entity.firerate
	/* todo instead maybe we can use sine or something
	to fade out */
	let firing = entity.firing
	if firing == true ? {
		let muscleflashduration = entity.muscleflashduration
		// firing = (ntoi(lgi_time()*(firerate/60.)) % 2) == 0
		fire(entity)
		firing = timediffs(entity.lastfire) < muscleflashduration
	}

	let facing = entity.facing
	let ybasis = facing
	let xbasis = ybasis:perp2d()
	canvas.xbasis = xbasis
	canvas.ybasis = ybasis:clone()
	canvas.xyz = entity.xyz
	fxsettex(textures.player,48*firing,0,48+48*firing,48)
	fxaddquad(-64,-64,+64,+64)
}
plotgame = fun() ? {
	plotgrid()

	canvas.xbasis = RIGHT
	canvas.ybasis = UP
	canvas.xyz = vec3(0,0,0)
	fxsettex(textures.background,0,0,64,64)
	fxaddquad(-64,-64,+64,+64)

	for i in Bullets:length() ? {
		let bullet = Bullets[i]
		if bullet != nil ? {
			let bulpos = bullet.pos:add(bullet.dir:mul1(20))
			bullet.pos = bulpos
			if bulpos:sub(bullet.from.xyz):len() > 1024 ? {
				Bullets[i] = nil
			} else /* todo: */
			for j in Entities:length() ? {
				let entity = Entities[j]
				if entity != nil ? {
					if bullet.from != entity ? {
						let entpos = entity.xyz
						if bulpos:sub(entpos):len() < 32 ? {
							// Entities[j] = nil
							// Bullets[i] = nil
						}
					}
				}
			}
		}
	}
	/* todo: restore previous fx state */
	for i in Entities:length() ? {
		let entity = Entities[i]
		if entity != nil ? {
			if entity != player ? {
				let diff = player.xyz:sub(entity.xyz)
				let dist = diff:len()
				let facing = diff:norm()
				entity.facing = facing
				if dist < 512 ? {
					fire(entity)
				} elif dist > 64 ? {
					//facing:mul1(.5)
					entity.xyz = entity.xyz:add(rnddir2(-PI,+PI,facing):mul1(.5))
				}
			}
			plotentity(entity)
		}
	}
	fxsettex(textures.player,8*16,4*16,9*16,5*16)
	for i in Bullets:length() ? {
		let bullet = Bullets[i]
		if bullet != nil ? {
			canvas.xyz = bullet.pos
			fxaddquad(-16,-16,+16,+16)
		}
	}
}



showgrid = false
trackplayer = true
editormode = false
shake = fun (mag) ? {
	let jitter = vec3(rnd(-1.,2.),rnd(-1.,2.),0.):norm():mul1(mag)
	/* todo: maybe add a feature like this := which
	removes this redundancy */
	camera.targetxyz = camera.targetxyz:add(jitter)
}


do {
	let width = lgi_getSizeX()
	let height = lgi_getSizeY()
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()
	/* todo: fix this */
	let cursor = vec3(xcursor,ycursor,0)
	player.facing = cursor:sub(plot3(player.xyz)):norm()

	if trackplayer ? {
		let diff = player.xyz:sub(camera.targetxyz)
		camera.targetxyz = camera.targetxyz:add(diff:mul1(.5))
	}

	let move = vec3(0,0,0)
	if lgi_iskeydown('W') ? move = move:add(UP)
	if lgi_iskeydown('A') ? move = move:add(LEFT)
	if lgi_iskeydown('S') ? move = move:add(DOWN)
	if lgi_iskeydown('D') ? move = move:add(RIGHT)
	player.xyz = player.xyz:add(move:norm():mul1(2))


	camera.xyz = camera.xyz:lerp(camera.targetxyz,.1)
	camera.xyz.z = 1

	if lgi_isbuttondown(0) ? {
		player.firing = true
		shake(50.)
	} else player.firing = false

	lgi_clearBackground();

	plotgame()

	// let temp = ftemp()
	// fpf(temp,"fps: ",1./lgi_deltatime(), ", num: ", World:length(), ", ", critters:length())
	// let fps = freadall(temp)
	// fclose(temp)
	// plottext(0,0,fps)
} while lgi_tick()


// elf.audio.play("welcome.mp3")
// let sound = elf.audio.newsound("welcome.mp3")
// let thread = elf.threads.create(fun() ? {
// })
// thread:launch()
// thread:join()
// elf.threads.post()
// elf.sys.timediffs()
// elf.sys.closehandles()
//
// let file = elf.sys.file("filename.png","rbw")
// file:read()
// file:write()
//
// elf.win32.Sleep()
// elf.win32.CreateThread()
// elf.win32.CreateWindow()
// elf.console.write()
// elf.console.read()
// /* the first window created is the main window */
/* not sure if video, or vio, for video io */
// elf.video.window(720,720,"Welcome")
// elf.video.resize(720,720)
// elf.video.nologo()
// /* a target can be a window or texture */
// elf.video.target(elf.video.MAINWINDOW)
// elf.video.camera({})
// elf.video.mode3d()
// elf.video.mode2d()
// elf.video.clear()
// elf.video.clearcolor()
// elf.video.colormode()
// elf.video.loadshader()
// elf.video.bindshader()
// elf.video.loadtexture()
// elf.video.bindtexture()
//