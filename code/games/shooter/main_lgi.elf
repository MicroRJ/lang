log ?= elf.pf
if load "code/games/lgi.elf" != true ? {
	leave false
}
if _chdir("code/games/shooter") ? {
	log("invalid pwd: ", pwd())
	leave false
}
load "vec.elf"
load "rnd.lang"


LEFT  = vec3(-1, 0, 0)
RIGHT = vec3( 1, 0, 0)
UP    = vec3( 0, 1, 0)
DOWN  = vec3( 0,-1, 0)
/* these are world directions, named as what
they look to the user */
NW = vec3(0,1,0)
NE = vec3(1,0,0)
SW = vec3(-1,0,0)
SE = vec3(0,-1,0)

camera = {
	"targetxyz" = vec3(0,0,0),
	"xyz" = vec3(0,0,0)
}


lgi_initWindowed(1024,720, "shooter")

loadassets = fun() ? {
	let time_ = clocktime()
	finally log("loaded assets, took => ", timediffs(time_))
	log("loading assets... ")
	textures = {
		"player" = lgi_loadtexture("assets/Atlas.png"),
		"background" = lgi_loadtexture("assets/background.png"),
	}
	for i in 0..textures:length() ? {
		lgi_setsampler(textures:idx(i),"point")
	}
}
loadassets()


plot3 = fun(xyz) ? plot(xyz.x,xyz.y,xyz.z)
plot = fun(x,y,z) ? {
	let xx = iton(x - camera.xyz.x)
	let yy = iton(y - camera.xyz.y)
	let zz = 1. ; iton(z - camera.xyz.z)
	; if zz == 0. ? zz = 1.
	let wx = (xx / zz) + lgi_getSizeX()*.5
	let wy = (yy / zz) + lgi_getSizeY()*.5
	leave vec3(wx,wy,0)
}
unplot = fun (xyz) ? {
	let cxyz = camera.xyz
	let cx = cxyz.x
	let cy = cxyz.y
	let cz = cxyz.z
	let wx = (xyz.x-lgi_getSizeX()*.5)// * (xyz.z + cz)
	let wy = (xyz.y-lgi_getSizeY()*.5)// * (xyz.z + cz)
	leave vec3(wx,wy,wz)
}
plotline = fun(x0,y0,x1,y1) ? {
	let xy0 = plot(x0,y0,0)
	let xy1 = plot(x1,y1,0)
	lgi_drawline(lgi_YELLOW,1,xy0.x,xy0.y,xy1.x,xy1.y)
}
plotline3 = fun(color,x0,y0,z0,x1,y1,z1) ? {
	let p0 = plot(x0,y0,z0)
	let p1 = plot(x1,y1,z1)
	lgi_drawline(color,1,p0.x,p0.y,p1.x,p1.y)
}
plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	plotline3(lgi_BLUE,x+0,y+0,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+0,z,x+0,y+1,z)
	plotline3(lgi_BLUE,x+1,y+1,z,x+1,y+0,z)
	plotline3(lgi_BLUE,x+0,y+1,z,x+1,y+1,z)
}
transform = fun(x,y,p) ? {
	leave vec3(p.x * x.x + p.y * x.y,
	           p.x * y.x + p.y * y.y,0.)
}
canvas = {
	"xyz" = vec3(0,0,0),
	"ybasis" = UP,
	"xbasis" = RIGHT,
	"color" = lgi_WHITE,
	"u0" = 0,
	"v0" = 0,
	"u1" = 1,
	"v1" = 1,
}
lgi_vertex2d = fun(x,y,u,v) ? {
	let xyz = transform(canvas.ybasis,canvas.xbasis,vec2(x,y))
	let p = plot3(canvas.xyz:add(xyz))
	lgi_attrxyuv(p.x,p.y,u,v)
	lgi_pushvertex()
}
fxsettex = fun(tex,u0,v0,u1,v1) ? {
	canvas.texture = tex
	if tex != nil ? {
		let width = lgi_gettexturewidth(tex)
		let height = lgi_gettextureheight(tex)
		canvas.u0 = iton(u0) / width
		canvas.v0 = iton(v0) / height
		canvas.u1 = iton(u1) / width
		canvas.v1 = iton(v1) / height
	}
}
fxaddquad = fun(x0,y0,x1,y1) ? {
	let texture = canvas.texture
	let u0 = canvas.u0
	let v0 = canvas.v0
	let u1 = canvas.u1
	let v1 = canvas.v1
	if texture != nil ? {
		lgi_bindtexture(texture)
	} else lgi_binddeftex()

	lgi_beginvertices(6,4)
	let color = canvas.color
	lgi_attrrgba(color.r,color.g,color.b,color.a)
	lgi_addnidx(0,1,2, 0,2,3)
	lgi_vertex2d(x0,y0,u0,v1)
	lgi_vertex2d(x0,y1,u0,v0)
	lgi_vertex2d(x1,y1,u1,v0)
	lgi_vertex2d(x1,y0,u1,v1)
	lgi_closevertices()
}
Particles = {}
fire = fun(entity) ? {
	let firerate = entity.firerate
	let lastfire = entity.lastfire
	if timediffs(lastfire) > (1./(firerate/60.)) ? {
		entity.lastfire = clocktime()
		Particles:add({
			"from" = entity,
			"pos" = entity.xyz:clone(),
			"vel" = entity.facing:mul1(3000),
		})
	}
}
/* entities */
playercontroller = fun(entity) ? {
	let move = vec3(0,0,0)
	if lgi_iskeydown('W') ? move = move:add(UP)
	if lgi_iskeydown('A') ? move = move:add(LEFT)
	if lgi_iskeydown('S') ? move = move:add(DOWN)
	if lgi_iskeydown('D') ? move = move:add(RIGHT)
	/* todo: */
	entity.xyz = entity.xyz:add(move:norm():mul1(2))
}
enemycontroller = fun(entity) ? {
	let pos = entity.xyz
	let diftoplayer = player.xyz:sub(pos)
	let distoplayer = diftoplayer:len()
	let facing = diftoplayer:norm()
	let target = diftoplayer:sub(facing:mul(64.))
	if timediffs(entity.lastimpulse) > .5 ? {
		entity.lastimpulse = clocktime()
		let imp = rnddir2(-PI,+PI,target:norm())
		entity.vel = entity.vel:add(imp:mul1(10))
	}
	entity.xyz = pos:add(entity.vel)
	entity.vel = entity.vel:mul1(.9)
	entity.tofacing = facing:clone()
	/* only fire if we are facing the player, and we can see it */
	entity.firing = ntoi(distoplayer < 512)
}
bosscontroller = fun(entity) ? {
	let diftoplayer = player.xyz:sub(pos)
	let distoplayer = diftoplayer:len()
	let facing = diftoplayer:norm()
	entity.facing = facing
	if timediffs(entity.ulttimer) > 4.5 ? {
		entity.ulttimer = clocktime()
		for i in 0..8 ? {
			Particles:add({
				"from" = entity,
				"pos" = entity.xyz:clone(),
				"vel" = rnddir2(-PI*.25,+PI*.25,facing):mul1(500),
			})
		}
	}
}
newentity = fun(pos,fr) ? {
	fr ?= 50
	/* firerate rps, rounds per minute */
	leave ({
		controller = enemycontroller,
		xyz = pos,
		vel = vec(),
		facing = UP,
		tofacing = UP,
		firing = false,
		firerate = fr,
		lastfire = 0,
		ulttimer = 0,
		health = 100,
		muscleflashduration = .032,
		lastimpulse = clocktime(),
	})
}

player = newentity(vec3(0,0,1),500)
boss = newentity(vec3(0,0,1),500)
boss.controller = bosscontroller
player.controller = playercontroller

Entities = {player,boss}
for i in 2..2+2 ? {
	Entities[i] = newentity(vec3(rnd(-128,128),rnd(-128,128),1))
}

plotentity = fun(entity) ? {
	let firerate = entity.firerate
	/* todo instead maybe we can use sine or something
	to fade out */
	let firing = entity.firing
	if firing == true ? {
		let muscleflashduration = entity.muscleflashduration
		fire(entity)
		firing = timediffs(entity.lastfire) < muscleflashduration
	}

	/* todo: we need something fancier for this */
	entity.facing = entity.facing:mix(entity.tofacing,.1):norm()

	let facing = entity.facing
	let ybasis = facing
	let xbasis = ybasis:perp2d()
	canvas.xbasis = xbasis
	canvas.ybasis = ybasis:clone()
	canvas.xyz = entity.xyz:clone()
	fxsettex(textures.player,48*firing,0,48+48*firing,48)
	fxaddquad(-64,-64,+64,+64)

	canvas.xbasis = UP
	canvas.ybasis = RIGHT
	canvas.color = lgi_RED;
	fxsettex(nil,0,0,0,0)
	fxaddquad(-16,-4,+16,+4)
	canvas.color = lgi_GREEN;
	fxaddquad(-16,-4,remix(iton(entity.health),0.,100.,-16.,16.),+4)

	canvas.color = lgi_WHITE;
}
plotgame = fun() ? {
	let delta = lgi_deltatime()
	canvas.xbasis = RIGHT
	canvas.ybasis = UP
	fxsettex(textures.background,0,0,64,64)
	for y in 0..4 ? {
		for x in 0..4 ? {
			canvas.xyz = vec2(128.*x,128.*y)
			fxaddquad(-64,-64,+64,+64)
		}
	}

	for i in Particles:length() ? {
		let bullet = Particles:idx(i)
		if bullet != nil ? {
			let bulpos = bullet.pos:add(bullet.vel:mul1(delta))
			bullet.vel = bullet.vel:mul1(0.999)
			bullet.pos = bulpos
			if bulpos:sub(bullet.from.xyz):len() > 1024 ? {
				Particles:xrem(i) i = i - 1
			} else for j in Entities:length() ? {
				/* todo: make this faster */
				let entity = Entities[j]
				if entity != nil ? {
					if bullet.from != entity ? {
						let entpos = entity.xyz
						let dif = bulpos:sub(entpos)
						if dif:len() < 32 ? {
							if entity.health > 1 ? {
								entity.health = entity.health - 1
							}
							let imp = dif:norm():mul1(10)
							entity.vel = entity.vel:add(imp)
							// Entities[j] = nil

							Particles:xrem(i) i = i - 1
							/* todo: breaks! */
							j = 100000000
						}
					}
				}
			}
		}
	}
	/* todo: restore previous fx state */
	for i in Entities:length() ? {
		let entity = Entities[i]
		if entity != nil ? {
			entity.controller(entity)
			plotentity(entity)
		}
	}
	fxsettex(textures.player,8*16,4*16,9*16,5*16)
	for i in Particles:length() ? {
		let bullet = Particles:idx(i)
		if bullet != nil ? {
			canvas.xyz = bullet.pos:clone()
			fxaddquad(-16,-16,+16,+16)
		}
	}
}



showgrid = false
trackplayer = true
editormode = false
shake = fun (mag) ? {
	let jitter = vec3(rnd(-1.,2.),rnd(-1.,2.),0.):norm():mul1(mag)
	/* todo: maybe add a feature like this := which
	removes this redundancy */
	camera.targetxyz = camera.targetxyz:add(jitter)
}

do {
	let width = lgi_getSizeX()
	let height = lgi_getSizeY()
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()
	/* todo: fix this */
	let cursor = vec3(xcursor,ycursor,0)
	player.facing = cursor:sub(plot3(player.xyz)):norm()

	if trackplayer ? {
		let diff = player.xyz:sub(camera.targetxyz)
		camera.targetxyz = camera.targetxyz:add(diff:mul1(.5))
	}


	camera.xyz = camera.xyz:lerp(camera.targetxyz,.1)
	camera.xyz.z = 1

	if (lgi_isbuttondown(0) || lgi_iskeydown(' ')) ? {
		player.firing = true
		shake(50.)
	} else player.firing = false

	lgi_clearBackground();

	plotgame()

	// let temp = ftemp()
	// fpf(temp,"fps: ",1./lgi_deltatime())
	// let fps = freadall(temp)
	// fclose(temp)
	// plottext(0,0,fps)
} while lgi_tick()


// elf.audio.play("welcome.mp3")
// let sound = elf.audio.newsound("welcome.mp3")
// let thread = elf.threads.create(fun() ? {
// })
// thread:launch()
// thread:join()
// elf.threads.post()
// elf.sys.timediffs()
// elf.sys.closehandles()
//
// let file = elf.sys.file("filename.png","rbw")
// file:read()
// file:write()
//
// elf.win32.Sleep()
// elf.win32.CreateThread()
// elf.win32.CreateWindow()
// elf.console.write()
// elf.console.read()
// /* the first window created is the main window */
/* not sure if video, or vio, for video io */
// elf.video.window(720,720,"Welcome")
// elf.video.resize(720,720)
// elf.video.nologo()
// /* a target can be a window or texture */
// elf.video.target(elf.video.MAINWINDOW)
// elf.video.camera({})
// elf.video.mode3d()
// elf.video.mode2d()
// elf.video.clear()
// elf.video.clearcolor()
// elf.video.colormode()
// elf.video.loadshader()
// elf.video.bindshader()
// elf.video.loadtexture()
// elf.video.bindtexture()
//