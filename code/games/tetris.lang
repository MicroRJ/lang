// NOTE:
// this is a crude tetris clone and it is probably the worst
// implementation ever since rotations are not even right!
// todo: projections
// todo: reflections
// todo: wall kicks
// todo: at least put shapes in a subgrid for proper rotations

__logging(false)
load "code/games/lgi.lang"


let enum vec2 = fun(x,y) ? ({"x"=x,"y"=y})
let enum vec2_add = fun(x,y) ? vec2(x.x+y.x,x.y+y.y)


// if a piece has .5 seconds before locking down
// and the turn timer is .5 seconds, then there's
// no need to add any additional logic for
// checking whether a separate lock timer has
// expired, right...?
TURN_TIME = .5


let enum {
	ID_FLOOR = 0,
	ID_WALL  = 1,
}
ID_NEXT = 2


let enum idtocolor = {
	"F" = lgi_BLACK,
	"W" = lgi_GRAY,
	"I" = lgi_CYAN,
	"L" = lgi_YELLOW,
	"T" = lgi_MAGENTA,
	"O" = lgi_ORANGE,
	"S" = lgi_GREEN,
}

let enum BAG = {
	// [ ][*][ ][ ]
	I = {id="I",p={vec2(0,0),vec2(-1,0),vec2(+1,0),vec2(+2,0)}},
	// [*][ ][ ]
	// [ ]
	L = {id="L",p={vec2(0,0),vec2(1,0),vec2(2,0),vec2(0,-1)}},
	// [ ][*][ ]
	// 	[ ]
	T = {id="T",p={vec2(0,0),vec2(-1,0),vec2(+1,0),vec2(0,-1)}},
	//  [*][ ]
	//  [ ][ ]
	O = {id="O",p={vec2(0,0),vec2(1,0),vec2(0,-1),vec2(1,-1)}},
	//     [*][ ]
	//  [ ][ ]
	S = {id="S",p={vec2(0,0),vec2(0,-1),vec2(1,0),vec2(-1,-1)}},
}


let enum MAP = {
	0 = "I",
	1 = "L",
	2 = "T",
	3 = "O",
	4 = "S",
}

let enum makecell = fun(colorid,stateid) ? ({"colorid"=colorid,"stateid"=stateid})

let grid = {}

for i in 0..512 ? grid[i] = makecell("F",ID_FLOOR)


let enum {
	grid_x = 10,
	grid_y = 20,
	cellpx = 28,
}

next_shape = {}
this_shape = {}
position = vec2(5,20-3)
rotation = {}


let enum get = fun (x,y) ? (grid[12 * y + x])

let enum plot = fun (x,y,s,c) ? {
	let cell = get(x,y)
	cell.stateid = s
	cell.colorid = c
}


let enum htest = fun (y) ? {
	for x in 1..11 ? if get(x,y).stateid != ID_FLOOR ? leave true
	leave false
}

let enum hline = fun (y) ? {
	for x in 1..11 ? if get(x,y).stateid == ID_FLOOR ? leave false
	leave true
}


let enum xorshift = fun(x) ? {
	x = x ^ x << 13
	x = x ^ x >> 7
	x = x ^ x << 17
	leave x
}


rndstate = 5282
let enum rnd = fun (x,y) ? {
	rndstate = xorshift(rndstate)
	if rndstate < 0 ? rndstate = -rndstate
	leave x + rndstate % (y - x)
}


let enum next = fun() ? {
	position.x = 5
	position.y = 21
	ID_NEXT = ID_NEXT + 1
	let index = rnd(0,BAG:length() - 1)
	this_shape = BAG[MAP[index]]
	leave 1
}


let enum prp = fun (v,clockwise) ? (vec2(v.y-(1-clockwise),(1-clockwise)-v.x))


let enum can = fun (x,y) ? {
	if   x >= 11 ? leave 0
	elif x <=  0 ? leave 0
	elif y <=  0 ? leave 0
	else {
		let cell = get(x,y)
		if cell.stateid != ID_NEXT ? {
			if cell.stateid != ID_FLOOR ? {
				leave false
			}
		}
	}
	leave true
}

let enum move = fun (dx,dy) ? {
	let p = this_shape.p
	let x = position.x
	let y = position.y
	let px = x + dx
	let py = y + dy
	for i in 0..4 ? iff can(px+p[i].x,py+p[i].y) ? leave(false)
	position.x = px
	position.y = py
	let c = this_shape.id
				/* clear previous shape */
	for i in 0..4 ? plot(x+p[i].x,y+p[i].y,ID_FLOOR,"F")
				/* draw new one */
	for i in 0..4 ? plot(px+p[i].x,py+p[i].y,ID_NEXT,c)

	leave(true)
}

// copy src row to dst row
let rowcopy = fun (dy,sy) ? {
	for x in 1..11 ? {
		let dc = get(x,dy)
		let sc = get(x,sy)
		dc.colorid = sc.colorid
		dc.stateid = sc.stateid
	}
}

// shift down n items starting at y such that y.. = (y + n)..
let vshft = fun (y,n) ? {
	let c = 20 - y - n
	for i in 0..c ? {
		rowcopy(y+i,y+i+n)
	}
}

let enum nline = fun (y) ? {
	let n = 0
	while hline(y) ? {
		y = y + 1
		n = n + 1
	}
	leave n
}

// do this before the next shape is generated,
// otherwise it'll shift it too
let enum line = fun () ? {
	for y in 1..20 ? {
		if hline(y) ? {
			// count number of lines after the one we found
			let n = nline(y+1)
			vshft(y,n+1)
			y = y + n
		}
	}
}

let enum rotate = fun(clockwise) ? {
	let p = this_shape.p
	let q = position
	for i in 0..4 ? {
		let r = prp(p[i],clockwise)
		let x = q.x + r.x
		let y = q.y + r.y
		iff can(x,y) ? leave false
	}
	let c = this_shape.id
	/* clear previous shape */
	for i in 0..4 ? plot(q.x+p[i].x,q.y+p[i].y,ID_FLOOR,"F")
	/* store rotated points */
	for i in 0..4 ? p[i] = prp(p[i],clockwise)
	/* draw new points */
	for i in 0..4 ? plot(q.x+p[i].x,q.y+p[i].y,ID_NEXT,c)
	leave true
}



let enum vtrace = fun (x,y,c,l) ? {
	for i in y..l ? plot(x,i,0,c)
}
let enum htrace = fun (x,y,c,l) ? {
	for i in x..l ? plot(i,y,0,c)
}
let enum clear = fun() ? {
	htrace( 0,0,"W",12)
	vtrace( 0,0,"W",22)
	vtrace(11,0,"W",22)
	for i in 1..22 ? htrace(1,i,"F",11)
}

lgi_initWindowed(28*(12+2)+(16*2), 28*(22+2)+(16*2), "tetris")
clear()
next()
move(0,0) /* trigger draw */

let size_x = lgi_getSizeX()
let size_y = lgi_getSizeY()

/* new turn when timer hits zero */
let turn_timer = TURN_TIME
let gameover = false
do {
	let delta = lgi_deltatime()
	turn_timer = turn_timer - delta
	if lgi_testKey('A') ? {
		move(-1,0)
	} elif lgi_testKey('D') ? {
		move(+1,0)
	} elif lgi_testKey('W') ? {
		rotate(true)
	} elif lgi_testKey('S') ? {
		turn_timer = 0.
	}
	if turn_timer <= 0. ? {
		turn_timer = TURN_TIME
		iff move(0,-1) ? {
		 	// do this before the next shape is
		 	// generated and plotted
			if htest(20) ? clear()
			/* then */
			line()
			next()
		}
	}

	lgi_clearBackground(lgi_BLACK)
	for y in 0..22  ? {
		for x in 0..12 ? {
			let cell = get(x,y)
			let colorid = cell.colorid
			let color = idtocolor[colorid]
			if colorid != nil ? {
				let box_x = 16 + x * (cellpx+2)
				let box_y = 16 + y * (cellpx+2)
				lgi_drawQuad(color,box_x,box_y,cellpx,cellpx)
			}
		}
	}
} while lgi_tick()


