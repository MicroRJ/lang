__logging(false)

load "code/games/lgi.lang"

lerp = fun(x,y,z) ? (y + x * (z - y))
unlerp = fun(x,y,z) ? ((x - y) / (z - y))
map = fun(x,y,z,w,v) ? lerp(unlerp(x,y,z),w,v)

vec2 = fun(x,y) ? ({"x"=x,"y"=y})
vec3 = fun(x,y,z) ? ({"x"=x,"y"=y,"z"=z})

/* todo: methods or methods overload */
vec2_add = fun(a,b) ? vec2(a.x+b.x,a.y+b.y)
vec3_add = fun(a,b) ? vec3(a.x+b.x,a.y+b.y,a.z+b.z)
vec3_sub = fun(a,b) ? vec3(a.x-b.x,a.y-b.y,a.z-b.z)
vec3_lerp = fun(t,a,b) ? vec3(lerp(t,a.x,b.x),lerp(t,a.y,b.y),lerp(t,a.z,b.z))
/* todo: */
vec3_floor = fun(a,b) ? vec3(ntoi(a.x),ntoi(a.y),ntoi(a.z))




// let enum {
// 	TILESET_ROWLEN =  10,
// 	TILE_SLOTDIMEN =  18,
// 	TILE_DRAWDIMEN = 128,
// }

let enum {
	TILESET_ROWLEN =  11,
	TILE_SLOTDIMEN =  32,
	TILE_DRAWDIMEN = 128,
	ISO_TILE_XSKEW = .50,
	ISO_TILE_YSKEW = .25,
	ISO_TILE_XSCALE = TILE_DRAWDIMEN * ISO_TILE_XSKEW,
	ISO_TILE_YSCALE = TILE_DRAWDIMEN * ISO_TILE_YSKEW,
	ISO_TILE_ZSCALE = TILE_DRAWDIMEN * ISO_TILE_YSKEW,
	/* todo: rename these */
	ISO_YTILT = TILE_DRAWDIMEN * .50,
	ISO_XTILT = TILE_DRAWDIMEN * .25,
}

Feet = {}
World = {}
WorldSide = 16
WorldSize = WorldSide*WorldSide*WorldSide
camerax = -256
cameray = 0
critterx = 0
crittery = 0



// let enum {
// 	GRASS  = 0,
// 	DIRT   = 6,
// 	AIR    = 9,
// 	WATER  = 23,
// 	OAK    = 30,
// 	LEAF   = 40,
// }

let enum {
	AIR    = 1000,
	DIRT   = 0,
	GRASS  = 23,
	FLOWER = 42,
	WATER  = 23,
	OAK    = 30,
	LEAF   = 40,
}


let enum xorshift = fun(x) ? {
	x = x ^ x << 13
	x = x ^ x >> 7
	x = x ^ x << 17
	leave x
}

rndstate = 5282
let enum rnd = fun(x,y) ? {
	rndstate = xorshift(rndstate)
	if rndstate < 0 ? rndstate = -rndstate
	leave x + rndstate % (y - x)
}

let toworldid = fun(x,y,z) ? {
	leave WorldSide*WorldSide*z + WorldSide * y + x
}

let toworldid3 = fun(xyz) ? toworldid(xyz.x,xyz.y,xyz.z)

let gettileid = fun(x,y,z) ? {
	leave World[toworldid(x,y,z)]
}

let gettileid3 = fun(xyz) ? gettileid(xyz.x,xyz.y,xyz.z)

let settileid = fun(tileid,x,y,z) ? {
	World[toworldid(x,y,z)] = tileid
}


World[0..WorldSize] = AIR
for y in 0..WorldSide ? {
	for x in 0..WorldSide ? {
		settileid(rnd(DIRT,DIRT+10),x,y,0)
	}
}
for i in 0..16 ? {
	settileid(GRASS,rnd(0,8),rnd(0,8),0)
	settileid(FLOWER,rnd(0,8),rnd(0,8),1)
}


// let addtree = fun(x,y) ? {
// 	settileid(OAK,x,y,1)
// 	settileid(OAK,x,y,2)
// 	settileid(LEAF,x,y,3)
// 	settileid(LEAF,x,y,4)
// 	settileid(LEAF,x+1,y,3)
// 	settileid(LEAF,x-1,y,3)
// 	settileid(LEAF,x,y+1,3)
// 	settileid(LEAF,x,y-1,3)
// }
// addtree(1,1)

let enum {
	LEFT  = vec2(-1, 0),
	RIGHT = vec2( 1, 0),
	UP    = vec2( 0, 1),
	DOWN  = vec2( 0,-1),
}


lgi_initWindowed(720,512, "rogue")

/* make it so that we change the default sampler */
textures = {
	"tiles" = lgi_loadtexture("code/games/tiles2.png"),
	"stag" = lgi_loadtexture("code/games/critter_stag_NE_idle.png"),
	"wolf" = lgi_loadtexture("code/games/wolf-idle.png"),
}

for i in 0..textures:length() ? {
	lgi_setsampler(textures:idx(i),"point")
}


unplot = fun (x,y) ? {
	let xx = (x + camerax) / ISO_TILE_XSKEW
	let yy = (y + cameray) / ISO_TILE_YSKEW
	let zz = TILE_DRAWDIMEN * 2.
	leave vec3_floor(vec3( (yy + xx) / zz, (yy - xx) / zz, 0))
}


plotline = fun(x0,y0,x1,y1) ? {
	let ix0 = (x0 - y0) * ISO_TILE_XSCALE - camerax
	let iy0 = (x0 + y0) * ISO_TILE_YSCALE - cameray
	let ix1 = (x1 - y1) * ISO_TILE_XSCALE - camerax
	let iy1 = (x1 + y1) * ISO_TILE_YSCALE - cameray
	lgi_drawline(lgi_BLUE,1,ix0,iy0,ix1,iy1)
}


plotgrid = fun() ? {
	for i in 0..8 ? {
		plotline(0,i,8,i)
		plotline(i,0,i,8)
	}
}


plottileoutline = fun(xyz) ? {
	let x = xyz.x
	let y = xyz.y
	plotline(x,y,x+1,y+0)
	plotline(x,y,x+0,y+1)
	plotline(x+1,y+1,x+1,y+0)
	plotline(x+0,y+1,x+1,y+1)
}


plot = fun(x,y,z) ? {
	leave vec2(
	(x - y) * ISO_TILE_XSCALE - camerax,
	(x + y) * ISO_TILE_YSCALE + z*ISO_TILE_ZSCALE - cameray)
}


plottile = fun(tileid,x,y,z) ? {
	if tileid == AIR ? leave ()
	/* offset the tiles cuz of the sprite */
	let px = (x - y - 1) * ISO_TILE_XSCALE - camerax
	let py = (x + y - 1) * ISO_TILE_YSCALE + z*ISO_TILE_ZSCALE - cameray
	lgi_drawtexture(textures.tiles,px,py
	,TILE_DRAWDIMEN,TILE_DRAWDIMEN
	,TILE_SLOTDIMEN*(tileid%TILESET_ROWLEN)
	,TILE_SLOTDIMEN*(tileid/TILESET_ROWLEN)
	,TILE_SLOTDIMEN,TILE_SLOTDIMEN)
}


// let move = fun(x) ? {
// 	// camerax = camerax + -x.x * 10
// 	// cameray = cameray + -x.y * 10
// 	critterx = critterx + x.x
// 	crittery = crittery + x.y
// }


updatecritterstate = fun(this,state) ? {
	if state != this.state ? {
		this.prevstate = this.state
		this.state = state
	}
}

/* all critters are on a singular table,
indexed by position in world */
critters = {}

getcritter = fun(xyz) ? {
	leave critters[toworldid3(xyz)]
}


movecritter = fun(this,offset) ? {
	// if this.ismoving ? leave ()
	let origin = this.xyzmov
	let target = vec3_add(origin,offset)
	if target.x < 0 ? leave false
	if target.y < 0 ? leave false
	if target.z < 0 ? leave false
	let critter = getcritter(target)
	if critter != nil ? leave false
	critters[toworldid3(origin)] = nil
	critters[toworldid3(target)] = this
	this.xyzmov = target
	this.ismoving = true
	leave true
}


crittercontroller_player = fun(critter) ? {
	if lgi_testKey('W') ? movecritter(critter,RIGHT)
	if lgi_testKey('D') ? movecritter(critter,DOWN)
	if lgi_testKey('A') ? movecritter(critter,UP)
	if lgi_testKey('S') ? movecritter(critter,LEFT)
}


crittercontroller_dummy = fun(critter) ? {
	if critter.turntimer < .0 ? {
		critter.turntimer = critter.turnclock
		movecritter(critter,vec3(rnd(-1,2),rnd(-1,2),0))
		// if gettileid3(critter.xyz) == GRASS ? {
		// 	updatecritterstate(critter,"grazing")
		// } else {
		// 	updatecritterstate(critter,critter.prevstate)
		// }
	}
	critter.turntimer = critter.turntimer - lgi_deltatime()
}


critterplotter_stag = fun(this) ? {
	let xyz = this.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like this */
	// let px,py = plot(this.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y
	let xanim = 32 * ((lgi_time() / .128) % 21)
	if this.state == "grazing" ? {
		xanim = 32 * (21 + (lgi_time() / .512) % 4)
	}
	let w = 32.
	let h = 41.
	let a = h / w
	let s = 128

	px = px - s*.35
	py = py + s*.05
	// lgi_drawQuad(lgi_WHITE,px,py,s,s*a)
	lgi_drawtexture(textures.stag,px,py,s,s*a,xanim,0,32,41)
}


critterplotter_wolf = fun(this) ? {
	let xyz = this.xyz
	let x = xyz.x
	let y = xyz.y
	let z = xyz.z
	/* todo: #langfeature something like this */
	// let px,py = plot(critter.xyz){"x","y"}
	let pxy = plot(x,y)
	let px = pxy.x
	let py = pxy.y

	let xanim = 64 * ((lgi_time() / .128) % 26)
	let w = 64.
	let h = 64.
	let a = h / w
	let s = 256
	let v = s*a
	px = px - s*.5
	py = py - v*.2
	// lgi_drawQuad(lgi_WHITE,px,py,256,v)
	lgi_drawtexture(textures.wolf,px,py,s,v,xanim,64*3,64,64)
}


newcritter = fun(xyz) ? {
	let this = {}
	updatecritterstate(this,"idle")
	/* we iterate over the visible
	tiles to find entities to tick
	and draw, entities move and we
	may encounter them again within
	the same tick loop */
	this.ticked = false
	this.turnclock = 2.
	this.turntimer = 2.
	this.moveclock = .256
	this.movetimer = .0
	this.ismoving = false
	this.xyz = xyz
	this.xyzmov = xyz
	this.controller = crittercontroller_dummy
	this.plotter = critterplotter_stag

	critters[toworldid3(xyz)] = this
	leave this
}


newwolf = fun(xyz) ? {
	let this = newcritter(xyz)
	this.controller = crittercontroller_player
	this.plotter = critterplotter_wolf
	critters[toworldid3(this.xyz)] = this
	leave this
}


tickcritter = fun(this) ? {
	if this.ticked ? leave ()
	this.ticked = true
	this.controller(this)
	if this.movetimer >= this.moveclock ? {
		this.ismoving = false
		this.movetimer = 0
	}
	if this.ismoving ? {
		let movedelta = this.movetimer / this.moveclock
		this.xyz = vec3_lerp(movedelta,this.xyz,this.xyzmov)
		this.movetimer = this.movetimer + lgi_deltatime()
	}
}


plotcritter = fun(this) ? {
	this.ticked = false
	this.plotter(this)
	// plottileoutline(this.xyz)
}


for i in 0..4 ? {
	/* todo: #langfeature introduce new key word,
	which calls a function in object mode */
	newcritter(vec3(rnd(1,4),rnd(1,4),0))
}

newwolf(vec3(0,0,0))


forvisibletiles = fun(per) ? {
	for z in 0..12 ? {
		for y in 0..12 ? {
			let iy = 12-1-y
			for x in 0..12 ? {
				let ix = 12-1-x
				per(ix,iy,z)
			}
		}
	}
}


do {
	let xcursor = lgi_getcursorx()
	let ycursor = lgi_getcursory()

	// if 0 ? {
	// 	if lgi_testKey('W') ? move(UP)
	// 	if lgi_testKey('D') ? move(RIGHT)
	// 	if lgi_testKey('A') ? move(LEFT)
	// 	if lgi_testKey('S') ? move(DOWN)
	// } else {
	// 	if lgi_testKey('W') ? move(RIGHT)
	// 	if lgi_testKey('D') ? move(DOWN)
	// 	if lgi_testKey('A') ? move(UP)
	// 	if lgi_testKey('S') ? move(LEFT)
	// }

	lgi_clearBackground();

	forvisibletiles(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			tickcritter(critter)
		}
	})
	forvisibletiles(fun(x,y,z) ? {
		let tileid = gettileid(x,y,z)
		plottile(tileid,x,y,z)
	})
	forvisibletiles(fun(x,y,z) ? {
		let critter = critters[toworldid(x,y,z)]
		if critter != nil ? {
			plotcritter(critter)
		}
	})


	if lgi_isbuttondown(0) ? {
		let world = unplot(xcursor,ycursor)
		plottileoutline(vec3(world.x,world.y,0))
		settileid(GRASS,world.x,world.y,0)
		// plotgrid()
	}

} while lgi_tick()





