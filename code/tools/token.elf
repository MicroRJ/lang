/*
** See Copyright Notice In elf.h
** token.elf
** Metaprogram to generate ltoken.h
*/


pf("generate ltoken.h? (y/n)")

let will = _getch()
if will != 'y' ? {
	leave ()
}

_chdir("code/tools")

pf("generating tokens file...")
let file = fopen("ltoken_lastGen.h","wb")
finally fclose(file)
let _time = clocktime()
finally pf(" => took ", timediffs(_time))



id = 0
newid = fun() ? {
	id = id + 1
	leave id - 1
}


TK_CLASS_NONE     = -2
TK_CLASS_KEYWORD  = -1
TK_CLASS_RANGE    =  1
TK_CLASS_OR       =  2
TK_CLASS_AND      =  3
TK_CLASS_BXOR     =  4
TK_CLASS_BOR      =  5
TK_CLASS_BAND     =  6
TK_CLASS_EQL      =  7
TK_CLASS_REL      =  8
TK_CLASS_SHIFT    =  9
TK_CLASS_ADD      = 10
TK_CLASS_MUL      = 11


K = TK_CLASS_KEYWORD
N = TK_CLASS_NONE
MUL = TK_CLASS_MUL
MUL = TK_CLASS_MUL
MUL = TK_CLASS_MUL
ADD = TK_CLASS_ADD
ADD = TK_CLASS_ADD
SHIFT = TK_CLASS_SHIFT
SHIFT = TK_CLASS_SHIFT
REL = TK_CLASS_REL
REL = TK_CLASS_REL
REL = TK_CLASS_REL
REL = TK_CLASS_REL
EQL = TK_CLASS_EQL
EQL = TK_CLASS_EQL
BAND = TK_CLASS_BAND
BXOR = TK_CLASS_BXOR
BOR = TK_CLASS_BOR
AND = TK_CLASS_AND
OR = TK_CLASS_OR
RANGE = TK_CLASS_RANGE


newtk = fun(x,r,s) ? {
	let myid = newid()
	let h = 0
	if r == K ? h = s:hash()
	leave ({"n"=x,"r"=r,"s"=s,"v"=myid,"h"=h})
}


tklist = {
	newtk("NONE", N, "none"),
	newtk("ELF", K, "elf"),
	newtk("NEW", K, "new"),
	newtk("THIS", K, "this"),
	newtk("ENUM", K, "enum"),
	newtk("FUN", K, "fun"),
	newtk("NIL", K, "nil"),
	newtk("LOCAL", K, "local"),
	newtk("LET", K, "let"),
	newtk("FINALLY", K, "finally"),
	newtk("IN", K, "in"),
	newtk("FOR", K, "for"),
	newtk("FOREACH", K, "foreach"),
	newtk("WHILE", K, "while"),
	newtk("DO", K, "do"),
	newtk("BREAK", K, "break"),
	newtk("CONTINUE", K, "continue"),
	newtk("LEAVE", K, "leave"),
	newtk("IF", K, "if"),
	newtk("IFF", K, "iff"),
	newtk("ELIF", K, "elif"),
	newtk("THEN", K, "then"),
	newtk("ELSE", K, "else"),
	newtk("LOAD", K, "load"),
	newtk("TRUE", K, "true"),
	newtk("FALSE", K, "false"),
	newtk("STKGET", K, "stkget"),
	newtk("STKLEN", K, "stklen"),
	newtk("INTEGER", N, "literal-integer"),
	newtk("NUMBER", N, "literal-number"),
	newtk("STRING", N, "literal-string"),
	newtk("LETTER", N, "literal-letter"),
	newtk("WORD", N, "identifier"),
	newtk("QMARK", N, "?"),
	newtk("NEGATE", N, "!"),
	newtk("ASSIGN_QUESTION", N, "?="),
	newtk("ASSIGN", N, "="),
	newtk("COLON", N, ":"),
	newtk("SEMI_COLON", N, ";"),
	newtk("DOT", N, "."),
	newtk("COMMA", N, ","),
	newtk("SQUARE_LEFT", N, "["),
	newtk("SQUARE_RIGHT", N, "]"),
	newtk("CURLY_LEFT", N, "{"),
	newtk("CURLY_RIGHT", N, "}"),
	newtk("PAREN_LEFT", N, "("),
	newtk("PAREN_RIGHT", N, ")"),
	newtk("MUL", MUL, "*"),
	newtk("DIV", MUL, "/"),
	newtk("MODULUS", MUL, "%"),
	newtk("ADD", ADD, "+"),
	newtk("SUB", ADD, "-"),
	newtk("RIGHT_SHIFT", SHIFT, ">>"),
	newtk("LEFT_SHIFT", SHIFT, "<<"),
	newtk("LESS_THAN", REL, "<"),
	newtk("LESS_THAN_EQUAL", REL, "<="),
	newtk("GREATER_THAN", REL, ">"),
	newtk("GREATER_THAN_EQUAL", REL, ">="),
	newtk("EQUALS", EQL, "=="),
	newtk("NOT_EQUALS", EQL, "!="),
	newtk("BIT_AND", BAND, "&"),
	newtk("BIT_OR", BOR, "|"),
	newtk("BIT_XOR", BXOR, "^"),
	newtk("LOG_AND", AND, "&&"),
	newtk("LOG_OR", OR, "||"),
	newtk("DOT_DOT", RANGE, ".."),
}


fpf(file,"/*\n")
fpf(file,"** See Copyright Notice In elf.h\n")
fpf(file,"** (X) ltoken.h (Autogenerated)\n")
fpf(file,"** This file was autogenerated by token.lang in tools\n")
fpf(file,"*/\n\n\n")

let firstkeyword = -1
let lastkeyword = -1
for i in 0..tklist:length() ? {
	let tk = tklist[i]
	if tk.r == K ? {
		firstkeyword = i
		for j in i+1..tklist:length() ? {
			tk = tklist[j]
			if tk.r == K ? {
				lastkeyword = j
			} else {
				i = 100000
				j = 100000
			}
		}
	}
}
pf("here: ", firstkeyword, ", ", lastkeyword)

// todo: add support for backticks, to cope with
// my ocdness
fpf(file,"#define FIRST_KEYWORD ", firstkeyword, "\n")
fpf(file,"#define  LAST_KEYWORD ", lastkeyword, "\n\n\n")

fpf(file,"typedef struct ltoken {\n")
fpf(file,"\tunsigned char type;\n")
fpf(file,"\tllineid line;\n")
fpf(file,"\tunsigned int eol: 1;\n")
fpf(file,"\tunion {\n")
fpf(file,"\t\tchar *s;\n")
fpf(file,"\t\telf_int i;\n")
fpf(file,"\t\telf_num n;\n")
fpf(file,"\t};\n")
fpf(file,"} ltoken;\n\n\n")


fpf(file,"typedef enum ltokentype {\n")
for i in 0..tklist:length() ? {
	let tk = tklist[i]

	let x = fpf(file,"\tTK_",tk.n);
	for _ in x..24 ? fpf(file," ")
	fpf(file," = ",tk.v,",\n")
}
fpf(file,"} ltokentype;\n\n\n")

fpf(file,"typedef struct ltokenintel {\n")
fpf(file,"\tchar *name;\n")
fpf(file,"\tchar prec;\n")
fpf(file,"\telf_hashint hash;\n")
fpf(file,"} ltokenintel;\n\n\n")

fpf(file,"elf_globaldecl ltokenintel elfX_tokenintel[] = {\n")

for i in 0..tklist:length() ? {
	let tk = tklist[i]

	fpf(file,"\t{")
	let x = fpf(file,"\"",tk.s,"\", ")
	for _ in x..24 ? fpf(file," ")

	fpf(file,tk.r,", ",tk.h,"},\n")
	// fpf(file,"\t{\"",tk.s,"\", ",tk.r,", ",tk.h,"},\n")
	// fpf(file,"\t{\"",tk.s,"\", ",tk.r,", ",tk.h,"},\n")
}
fpf(file,"};\n\n\n")


