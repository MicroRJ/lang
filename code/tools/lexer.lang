

let _time = clocktime()
finally pf(" => took ", timediffs(_time))


id = 0
newid = fun() ? {
	id = id + 1
	leave id - 1
}

newtk = fun(x,r,s) ? {
	let myid = newid()
	leave ({"n"=x,"r"=r,"s"=s,"v"=myid})
}


TK_CLASS_NONE     = -2
TK_CLASS_KEYWORD  = -1
TK_CLASS_RANGE    =  1
TK_CLASS_OR       =  2
TK_CLASS_AND      =  3
TK_CLASS_BXOR     =  4
TK_CLASS_BOR      =  5
TK_CLASS_BAND     =  6
TK_CLASS_EQL      =  7
TK_CLASS_REL      =  8
TK_CLASS_SHIFT    =  9
TK_CLASS_ADD      = 10
TK_CLASS_MUL      = 11


K = TK_CLASS_KEYWORD
N = TK_CLASS_NONE
MUL = TK_CLASS_MUL
MUL = TK_CLASS_MUL
MUL = TK_CLASS_MUL
ADD = TK_CLASS_ADD
ADD = TK_CLASS_ADD
SHIFT = TK_CLASS_SHIFT
SHIFT = TK_CLASS_SHIFT
REL = TK_CLASS_REL
REL = TK_CLASS_REL
REL = TK_CLASS_REL
REL = TK_CLASS_REL
EQL = TK_CLASS_EQL
EQL = TK_CLASS_EQL
BAND = TK_CLASS_BAND
BXOR = TK_CLASS_BXOR
BOR = TK_CLASS_BOR
AND = TK_CLASS_AND
OR = TK_CLASS_OR
RANGE = TK_CLASS_RANGE

tklist = {
	/* todo: maybe something like this? */
	// [["k","v","n"]]:
	newtk("NONE", N, "none"),
	newtk("FUN", K, "fun"),
	newtk("NIL", K, "nil"),
	newtk("LOCAL", K, "local"),
	newtk("LET", K, "let"),
	newtk("FINALY", K, "finally"),
	newtk("IN", K, "in"),
	newtk("FOR", K, "for"),
	newtk("WHILE", K, "while"),
	newtk("DO", K, "do"),
	newtk("BREAK", K, "break"),
	newtk("CONTINUE", K, "continue"),
	newtk("LEAVE", K, "leave"),
	newtk("IF", K, "if"),
	newtk("IFF", K, "iff"),
	newtk("ELIF", K, "elif"),
	newtk("THEN", K, "then"),
	newtk("ELSE", K, "else"),
	newtk("LOAD", K, "load"),
	newtk("TRUE", K, "true"),
	newtk("FALSE", K, "false"),
	newtk("STKGET", K, "stkget"),
	newtk("STKLEN", K, "stklen"),
	newtk("INTEGER", N, "literal-integer"),
	newtk("NUMBER", N, "literal-number"),
	newtk("STRING", N, "literal-string"),
	newtk("LETTER", N, "literal-letter"),
	newtk("WORD", N, "identifier"),
	newtk("QMARK", N, "?"),
	newtk("NEGATE", N, "!"),
	newtk("ASSIGN_QUESTION", N, "?="),
	newtk("ASSIGN", N, "="),
	newtk("COLON", N, ":"),
	newtk("SEMI_COLON", N, ";"),
	newtk("DOT", N, "."),
	newtk("COMMA", N, ","),
	newtk("SQUARE_LEFT", N, "["),
	newtk("SQUARE_RIGHT", N, "]"),
	newtk("CURLY_LEFT", N, "{"),
	newtk("CURLY_RIGHT", N, "}"),
	newtk("PAREN_LEFT", N, "("),
	newtk("PAREN_RIGHT", N, ")"),
	newtk("MUL", MUL, "*"),
	newtk("DIV", MUL, "/"),
	newtk("MODULUS", MUL, "%"),
	newtk("ADD", ADD, "+"),
	newtk("SUB", ADD, "-"),
	newtk("RIGHT_SHIFT", SHIFT, ">>"),
	newtk("LEFT_SHIFT", SHIFT, "<<"),
	newtk("LESS_THAN", REL, "<"),
	newtk("LESS_THAN_EQUAL", REL, "<="),
	newtk("GREATER_THAN", REL, ">"),
	newtk("GREATER_THAN_EQUAL", REL, ">="),
	newtk("EQUALS", EQL, "=="),
	newtk("NOT_EQUALS", EQL, "!="),
	newtk("BIT_AND", BAND, "&"),
	newtk("BIT_OR", BOR, "|"),
	newtk("BIT_XOR", BXOR, "^"),
	newtk("LOG_AND", AND, "&&"),
	newtk("LOG_OR", OR, "||"),
	newtk("DOT_DOT", RANGE, ".."),
}

workdir("src")

file = fopen("ltoken2.h","wb")
finally fclose(file)


fpf(file,"/*\n")
fpf(file,"** See Copyright Notice In lang.h\n")
fpf(file,"** (X) ltoken.h (Autogenerated)\n")
fpf(file,"** This file was autogenerated by token.lang in tools\n")
fpf(file,"*/\n\n\n")

let firstkeyword = -1
let lastkeyword = -1
for i in 0..tklist:length ? {
	let tk = tklist[i]
	if tk.r == K ? {
		firstkeyword = i
		for i in i+1..tklist:length ? {
			tk = tklist[i]
			if tk.r == K ? {
				lastkeyword = i
			} else i = 10000
		}
	}
}

// todo: add support for backticks, to cope with
// my ocdness
fpf(file,"#define FIRST_KEYWORD ", firstkeyword, "\n\n")
fpf(file,"#define  LAST_KEYWORD ", lastkeyword, "\n\n")

pf(firstkeyword,", ",lastkeyword)

fpf(file,"typedef enum ltokentype {\n")
for i in 0..tklist:length ? {
	let tk = tklist[i]
	fpf(file,"\tTK_",tk.n," = ",tk.v,",\n")
}
fpf(file,"} ltokentype;\n\n\n")

fpf(file,"typedef struct ltokenintel {\n")
fpf(file,"\tchar *name;\n")
fpf(file,"\tchar  prec;\n")
fpf(file,"} ltokenintel;\n\n\n")

fpf(file,"lglobaldecl ltokenintel langX_tokenintel[] = {\n")

for i in 0..tklist:length ? {
	let tk = tklist[i]
	fpf(file,"\t{\"",tk.s,"\", ",tk.r,"},\n")
}
fpf(file,"};\n\n\n")

